{
  "hash": "f695b025022ed459277538aefc6f4850",
  "result": {
    "engine": "knitr",
    "markdown": "\n::: {.cell}\n\n:::\n\n\n# Scales {#sec-scales}\n\nSections [-@sec-colors], [-@sec-sizes], and [-@sec-shapes] showed how to set colors, sizes, and shapes for different types of spatial objects.\nIn them, we often used the `tm_scale()` function to modify the appearance of the map, such as changing the color palettes (`col.scale` and `fill.scale`), sizes (`size.scale`), or shapes (`shape.scale`).\nThe `tm_scale()` function automatically sets the scale for the given visual variable and the data type (factor, numeric, and integer).\nThus, for example, when we provide a character variable's name to the `fill` argument, then the `tm_scale()` function automatically sets the color scale for a categorical variable, and when we provide a numeric variable's name to the `size` argument, then the `tm_scale()` function automatically sets the size scale for a continuous variable.\n\nHowever, we often want to have more control over how our spatial objects are presented on the map.\nFor that purpose, the `tm_scale()` function comes with several derived functions that can be used to modify and customize the used scale.\n@tbl-scale-table presents all of them.\n\n<!-- tmap_options()$scales.var -->\n<!-- add short description of each scale function in the table below? -->\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n::: {#tbl-scale-table .cell layout-align=\"center\" tbl-cap='Map scales.'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Function </th>\n   <th style=\"text-align:left;\"> Description </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_categorical() </td>\n   <td style=\"text-align:left;width: 8cm; \"> Categorical scale </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_ordinal() </td>\n   <td style=\"text-align:left;width: 8cm; \"> Ordinal scale </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_discrete() </td>\n   <td style=\"text-align:left;width: 8cm; \"> Discrete scale </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_rank() </td>\n   <td style=\"text-align:left;width: 8cm; \"> Rank scale </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_intervals() </td>\n   <td style=\"text-align:left;width: 8cm; \"> Intervals scale </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_continuous() </td>\n   <td style=\"text-align:left;width: 8cm; \"> Continuous scale </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_continuous_log(), tm_scale_continuous_log2(), tm_scale_continuous_log10(), tm_scale_continuous_log1p(), tm_scale_continuous_sqrt(), tm_scale_continuous_pseudo_log() </td>\n   <td style=\"text-align:left;width: 8cm; \"> Logarithmic scales </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_asis() </td>\n   <td style=\"text-align:left;width: 8cm; \"> As-is scale </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_rgb() </td>\n   <td style=\"text-align:left;width: 8cm; \"> RGB scale </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> tm_scale_bivariate() </td>\n   <td style=\"text-align:left;width: 8cm; \"> Bivariate scale </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n@fig-scales shows examples of how some of them look like when applied to the same variable.\nIn the rest of the chapter, we go through each of the scales in more detail.\nWe mostly focus on using scales for the `fill.scale` argument, but the same principles apply to the `col.scale`, `size.scale`, and `shape.scale` arguments.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Examples of different scales applied to the same variable.](figures/fig-scales-1.png){#fig-scales fig-align='center' fig-pos='t' width=100%}\n:::\n:::\n\n\nThe examples in this chapter are based on the `slo_regions` dataset, which contains information about the regions of Slovenia.\nLet's read it first.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tmap)\nlibrary(sf)\nslo_regions = read_sf(\"data/slovenia/slo_regions.gpkg\")\n```\n:::\n\n\n## Categorical scales {#sec-categorical-scales}\n\n\\index{Categorical maps}\nAn example of a categorical map can be seen in @fig-colorscales2.\nWe created it by providing a character variable's name, `\"region_group\"`, in the `fill` argument. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"region_group\")\n# same as:\n# tm_shape(slo_regions) +\n#   tm_polygons(fill = \"region_group\", fill.scale = tm_scale_categorical())\n```\n\n::: {.cell-output-display}\n![Example of a map in which polygons are colored based on the values of a categorical variable.](figures/fig-colorscales2-1.png){#fig-colorscales2 fig-align='center' fig-pos='t' width=100%}\n:::\n:::\n\n\nThe `tm_polygons(fill = \"region_group\", fill.scale = tm_scale_categorical())` code is run automatically in the background in this case.\nIt is possible to change the names of legend labels with the `labels` argument of the `tm_scale()` function.\nAs mentioned in the @sec-colors, we can also change the color palette with the `values` argument.\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n## Ordinal scales {#sec-ordinal-scales}\n\nThe ordinal scale is similar to the categorical scale, but it is used for ordered categorical variables.\nBy default, this scale uses a sequential color palette, which is suitable for ordered categorical variables (@fig-ordinal-scales).\nWe may use `tm_scale_ordinal()` when the order of the values matters to highlight a hierarchy or ranking.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"region_group\",\n              fill.scale = tm_scale_ordinal())\n```\n\n::: {.cell-output-display}\n![Example of a map in which polygons are colored based on the values of an ordered categorical variable.](figures/fig-ordinal-scales-1.png){#fig-ordinal-scales fig-align='center' fig-pos='t' width=100%}\n:::\n:::\n\n\n## Discrete scales {#sec-discrete-scales}\n\n<!-- Martijn: a better example is probably needed here -- we could add some new variable to the data. -->\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"urbn_type\",\n              fill.scale = tm_scale_discrete())\n```\n\n::: {.cell-output-display}\n![Example of a map in which polygons are colored based on the values of a discrete variable.](figures/fig-discrete-scales-1.png){#fig-discrete-scales fig-align='center' fig-pos='t' width=100%}\n:::\n:::\n\n\n## Rank scales {#sec-rank-scales}\n\n<!-- Martijn: any ideas for a good example? -->\n\n## Intervals scales {#sec-intervals-scales}\n\n<!-- optimal number of classes? 3-7 -->\n\\index{Intervals maps}\nInterval scales are used to represent continuous numerical variables using a set of class intervals. \nIn other words, values are divided into several groups based on their properties.\nSeveral approaches can be used to convert continuous variables to intervals, and each of them could result in different groupings of values (@tbl-style-table).^[Most of these approaches in **tmap** use the **classInt** package [@R-classInt] internally, therefore, some additional information on their use can be found in the `?classIntervals` function's documentation.]\n\n\n::: {#tbl-style-table .cell layout-align=\"center\" tbl-cap='Styles available to create intervals maps.'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Style </th>\n   <th style=\"text-align:left;\"> Description </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"pretty\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Pretty breaks </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"fixed\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Manual breaks </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"equal\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Equal intervals </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"sd\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Standard deviation intervals </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"quantile\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Quantile intervals </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"jenks\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Jenks optimization breaks </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"fisher\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Fisher's method </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"dpih\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Kernel density estimation breaks </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"kmeans\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> K-means clustering breaks </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"bclust\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Bagged clustering breaks </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"hclust\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Hierarchical clustering breaks </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"headtails\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Head/tail breaks </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 4cm; font-family: monospace;\"> \"log10_pretty\" </td>\n   <td style=\"text-align:left;width: 8cm; \"> Logarithmic base-10 breaks </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n### Pretty breaks\n\nBy default, the `tm_scale_intervals()` function is used in the background (@fig-intervals-methods-1).\nIt uses a style called \"pretty\", which creates breaks that are whole numbers and spaces them evenly ^[For more information, visit the `?pretty()` function documentation].\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\")\n# same as:\n# tm_shape(slo_regions) +\n#   tm_polygons(fill = \"pop_dens\", fill.scale = tm_scale_intervals())\n```\n:::\n\n\nIt is also possible to indicate the desired number of classes using the `n` argument of the `tm_scale()` function provided to the `fill.scale` argument.\nWhile not every `n` is possible depending on the input values, **tmap** will try to create a number of classes as close as possible to the preferred one.\n\n### Manual breaks\n\nThe next approach is to manually select the limits of each break with the `breaks` argument of `tm_scale()` (@fig-intervals-methods-2).\nThis can be useful when we have some pre-defined breaks or when we want to compare values between several maps.\nIt expects threshold values for each break, therefore, if we want to have three breaks, we need to provide four thresholds.^[You may also use `-Inf` and `Inf` to represent the lowest and highest possible values, respectively.]\nAdditionally, we can add a label to each break with the `labels` argument.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\", \n              fill.scale = tm_scale_intervals(\n                breaks = c(0, 100, 150, 250),\n                labels = c(\"low\", \"medium\", \"high\"))\n              )\n```\n:::\n\n\n### Automatic breaks\n\nAnother approach is to create breaks automatically using one of many existing classification methods with the `style` argument of the `tm_scale()` function.\nThree basic methods are `\"equal\"`, `\"sd\"`, and `\"quantile\"` styles.\nLet's consider a variable with 100 observations with values ranging from 0 to 10.\nThe `\"equal\"` style divides them into *n* equal-sized intervals.\nThis style works well when the values change fairly continuously and do not contain any outliers.\nIn **tmap**, the number of classes will be computed automatically<!--?nclass.Sturges--> or we can specify the number of classes with the `n` argument.\nFor example, when we set `n` to 4, then our breaks will represent four classes ranging from 0 to 2.5, 2.5 to 5, 5 to 7.5, and 7.5 to 10.\nThe `\"sd\"` style represents how much the values of a given variable vary from its mean, with each interval having a constant width of the standard deviation.\nThis style is used when it is vital to show how values relate to the mean.\nThe `\"quantile\"` style creates several classes with exactly the same number of objects (e.g., spatial features), but having intervals of various lengths.\nThis method has an advantage in that it does not have any empty classes or classes with too few or too many values.\nHowever, the resulting intervals from the `\"quantile\"` style can often be misleading, with very different values located in the same class.\n\nTo create classes that, on the one hand, contain similar values, and on the other hand, are different from the other classes, we can use an optimization method.\nThe most common one used in cartography is the Jenks optimization method implemented as the `\"jenks\"` style (@fig-intervals-methods-3).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\", \n              fill.scale = tm_scale_intervals(style = \"jenks\"))\n```\n:::\n\n\nThe Fisher method (`style = \"fisher\"`) has a similar role, which creates groups with maximized homogeneity [@fisher_grouping_1958].\nA different approach is used by the `dpih` style, which uses kernel density estimations to select the width of the intervals [@wand_databased_1997].\nYou can visit `?KernSmooth::dpih` for more details.\n\nAnother group of classification methods uses existing clustering methods.\nIt includes k-means clustering (`\"kmeans\"`), bagged clustering (`\"bclust\"`), and hierarchical clustering (`\"hclust\"`). \nThey create classes based on the similarity of values, where the number of classes is specified with the `n` argument.\n\nFinally, there are a few methods created to work well for a variable with a heavy-tailed distribution, including `\"headtails\"` and `\"log10_pretty\"`.\nThe `\"headtails\"` style is an implementation of the head/tail breaks method aimed at heavily right-skewed data.\nIn it, values of the given variable are being divided around the mean into two parts, and the process continues iteratively for the values above the mean (the head) until the head part values are no longer heavy-tailed distributed [@jiang_head_2013].\nThe `\"log10_pretty\"` style uses a logarithmic base-10 transformation (@fig-intervals-methods-4).\nIn this style, each class starts with a value ten times larger than the beginning of the previous class.\nIn other words, each following class shows us the next order of magnitude.\nThis style allows for a better distinction between low, medium, and high values.\nHowever, maps with logarithmically transformed variables are usually less intuitive for the readers and require more attention from them.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\", \n              fill.scale = tm_scale_intervals(style = \"log10_pretty\"))\n```\n:::\n\n\n\n::: {#fig-intervals-methods .cell layout-ncol=\"2\" layout-align=\"center\"}\n::: {.cell-output-display}\n![\"pretty\" method](figures/fig-intervals-methods-1.png){#fig-intervals-methods-1 fig-align='center' fig-pos='t' width=100%}\n:::\n\n::: {.cell-output-display}\n![\"fixed\" method](figures/fig-intervals-methods-2.png){#fig-intervals-methods-2 fig-align='center' fig-pos='t' width=100%}\n:::\n\n::: {.cell-output-display}\n![\"jenks\" method](figures/fig-intervals-methods-3.png){#fig-intervals-methods-3 fig-align='center' fig-pos='t' width=100%}\n:::\n\n::: {.cell-output-display}\n![\"log10_pretty\" method](figures/fig-intervals-methods-4.png){#fig-intervals-methods-4 fig-align='center' fig-pos='t' width=100%}\n:::\n\nExamples of four methods of creating intervals maps.\n:::\n\n\n<!-- The numeric variable can be either regarded as a continuous variable or a count (integer) variable. See as.count. Only applicable if style is \"pretty\", \"fixed\", or \"log10_pretty\". -->\n\n## Continuous scales {#sec-continuous-scales}\n\n\\index{Continuous maps}\nContinuous maps also represent continuous numerical variables, but without any discrete class intervals (@fig-cont-methods).\nA few continuous methods exist in **tmap**, including `tm_scale_continuous()`, `tm_scale_rank()`, and `tm_scale_continuous_log10()`.\n\nThe `tm_scale_continuous()` function creates a smooth, linear gradient.\nIn other words, the change in values is proportionally related to the change in colors.\nWe can see that in @fig-cont-methods-1, where the value change from 50 to 100 has a similar impact on the color scale as the value change from 100 to 150.\nThe continuous scale is similar to the pretty style, where the values also change linearly.\nThe main difference between them is that we can distinguish between, for example, values of 110 and 140 in the former, while both values have exactly the same color in the latter.\nThe continuous scale works well in situations where there is a large number of spatial vector objects or a large number of raster cells, and where the values change continuously (do not have many outliers). \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.scale = tm_scale_continuous())\n```\n:::\n\n\nHowever, when the presented variable is skewed or has some outliers, we can use either `tm_scale_rank()` or `tm_scale_continuous_log10()`.\nThe `tm_scale_rank()` scale also uses a smooth gradient with a large number of colors, but the values on the legend do not change linearly (@fig-cont-methods-2).\n<!--JN: Martijn, please check the next sentence for correctness-->\nIt is fairly analogous to the `\"quantile\"` style, with the values on a color scale that divides a dataset into several equal-sized groups.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.scale = tm_scale_rank())\n```\n:::\n\n\nFinally, the `tm_scale_continuous_log10()` scale is the continuous equivalent of the `\"log10_pretty\"` style of `tm_scale_intervals()` (@fig-cont-methods-3).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.scale = tm_scale_continuous_log10())\n```\n:::\n\n\n\n::: {#fig-cont-methods .cell layout-nrow=\"3\" layout-align=\"center\"}\n::: {.cell-output-display}\n![\"continuous\" method](figures/fig-cont-methods-1.png){#fig-cont-methods-1 fig-align='center' fig-pos='t' width=100%}\n:::\n\n::: {.cell-output-display}\n![\"rank\" method](figures/fig-cont-methods-2.png){#fig-cont-methods-2 fig-align='center' fig-pos='t' width=100%}\n:::\n\n::: {.cell-output-display}\n![\"log10\" method](figures/fig-cont-methods-3.png){#fig-cont-methods-3 fig-align='center' fig-pos='t' width=100%}\n:::\n\nExamples of three methods of creating continuous maps.\n:::\n\n\n## As-is scales {#sec-asis-scales}\n\nIn most cases, we want to use a color scale based on the variable's values.\nThen, **tmap** takes these values, groups them into classes, and assigns a color to each class.\nHowever, it is also possible to use the values of the variables directly to specify the fill color or other visual properties of the spatial objects.\nFor example, your spatial vector data may contain a column with colors, such as `\"blue\"`, `\"red\"`, and `\"green\"`, and then we want to use these colors directly to color the polygons.\nThis is known as an as-is scale, and it can be used with the `tm_scale_asis()` function.\n\nLet's take a look at the `urbn_type_col` variable in the `slo_regions` dataset.\nIt contains the names of the colors (in a hexadecimal format) that we want to use to color the polygons.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nslo_regions$urbn_type_col\n#>  [1] \"#994F88\" \"#994F88\" \"#994F88\" \"#994F88\" \"#994F88\" \"#994F88\" \"#994F88\"\n#>  [8] \"#994F88\" \"#2CA02C\" \"#2CA02C\" \"#994F88\" \"#2CA02C\"\n```\n:::\n\n\nTo fill each polygon with the color specified in the `urbn_type_col` variable, we should specify that column with the `fill` argument of the `tm_polygons()` function and then set the `fill.scale` argument to `tm_scale_asis()` (@fig-asis-scales).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"urbn_type_col\",\n              fill.scale = tm_scale_asis()) \n```\n\n::: {.cell-output-display}\n![Example of a map in which polygons are directly colored based on the values of a variable (an as-is scale).](figures/fig-asis-scales-1.png){#fig-asis-scales fig-align='center' fig-pos='t' width=100%}\n:::\n:::\n\n\nThis scale does not return any legend -- it is not needed, as the colors are already specified in the data.\n\nThe `tm_scale_asis()` function can be used not only for the `fill` argument, but also for the `col`, `size`, `shape`, and other related arguments.\nIn such cases, the values of the variable should be appropriate for the visual property, e.g., a set of colors for `col` or a set of numeric values representing sizes, for `size`, and representing shapes for `shape`.\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n## RGB scales {#sec-rgb-scales}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(terra)\nsat = rast(\"data/slovenia/slo_mosaic.tif\")\n```\n:::\n\n\nThe `sat` **terra** object contains four bands of the Sentinel-2 image for Slovenia.\nThe bands (blue, green, red, and near-infrared) are stored as layer as `B02`, `B03`, `B04`, and `B08`.\nWe can plot all of the bands independently or as a combination of three bands.\nThis combination is known as a color composite image, and we can create such images with the `tm_rgb()` function (@fig-tmrgbs).\n\nStandard composite image (*true color composite*) uses the visible red, green, and blue bands to represent the data in natural colors.\nWe can specify which layer in `sat` relates to red (third band), green (second band), and blue (first band) color in `tm_rgb()` with the `tm_vars()` function.\nThe result is a true color composite, with green colors representing forests and other types of vegetation, and yellow-ish colors showing bare areas (@fig-tmrgbs-1).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(sat) +\n  tm_rgb(tm_vars(x = c(\"B04\", \"B03\", \"B02\"),  multivariate = TRUE),\n         col.scale = tm_scale_rgb(stretch = TRUE, probs = c(0.02, 0.98)))\n```\n:::\n\n\n::: {.callout-note}\nThe `tm_vars()` function allows to specify more than one variable to be visualized at the same time. \nThis is useful when we want to present a few variables as facets or combine multiple variables or layers to create a color composite image (`tm_rgb()`), a bivariate map, or an animation.\nIts main arguments: \n\n- `x`: variable names, variable indices, or a dimension name (for `sf`, `stars`, and `SpatRaster` objects)\n- `dimvalues`: dimension values (for `stars` objects)\n- `n`: (if specified) the first *n* variables that are used\n- `multivariate`: in case multiple variables are specified, should they serve as facets (FALSE; default) or as a multivariate visual variable?\n<!-- - `animate`: should the variable(s) be animated? -->\n:::\n\nTrue color images are straightforward to interpret and understand, but they make subtle differences in features challenging to recognize.\nHowever, nothing stops us from using the above tools to integrate different bands to create so called *false color composites*.\nVarious band combinations emphasize some spatial characteristics, such as water, agriculture, etc., and allow us to visualize wavelengths that our eyes can not see.\n<!-- add some reference?? -->\n@fig-tmrgbs-2 shows a composite of near-infrared, red, and green bands, highlighting vegetation with a bright red color.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(sat) +\n  tm_rgb(tm_vars(x = c(\"B08\", \"B04\", \"B03\"), multivariate = TRUE),\n         col.scale = tm_scale_rgb(stretch = TRUE, probs = c(0.02, 0.98)))\n```\n:::\n\n\n\n::: {#fig-tmrgbs .cell layout-nrow=\"1\" layout-align=\"center\"}\n::: {.cell-output-display}\n![True color composite image](figures/fig-tmrgbs-1.png){#fig-tmrgbs-1 fig-align='center' fig-pos='t' width=100%}\n:::\n\n::: {.cell-output-display}\n![False color composite image](figures/fig-tmrgbs-2.png){#fig-tmrgbs-2 fig-align='center' fig-pos='t' width=100%}\n:::\n\nTwo color composite images\n:::\n\n\nThe above examples use **terra**'s `SpatRaster` objects as input, but the `tm_rgb()` function can also work with `stars` objects.\nFor example, we can read the same GeoTIFF file with the `read_stars()` function and then use the `tm_rgb()` function to create a color composite image.\nHowever, in this case we need to specify the `dimvalues` argument of the `tm_vars()` function as the `sat_stars` object consists of one attribute (`x = \"slo_mosaic.tif\"`) with four dimensions (bands; `dimvalues = c(\"B04\", \"B03\", \"B02\")`).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(stars)\nsat_stars = read_stars(\"data/slovenia/slo_mosaic.tif\")\ntm_shape(sat_stars) +\n  tm_rgb(tm_vars(x = \"slo_mosaic.tif\", dimvalues = c(\"B04\", \"B03\", \"B02\"), \n                 multivariate = TRUE),\n         col.scale = tm_scale_rgb(stretch = TRUE, probs = c(0.02, 0.98)))\n```\n:::\n\n\n## Bivariate scales {#sec-bivariate-scales}\n\n\\index{Bivariate maps}\nIn cases when we have two variables that we want to visualize, the most common approach is to create two separate maps, one for each variable (@fig-bivariate-scales1).\nWe can also do that using the `tm_vars()` function, which allows us to specify multiple variables (see the code below) or with the facet functions (see @sec-facets).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = tm_vars(c(\"pop_dens\", \"pop65perc\")),\n              fill.scale = tm_scale(values = \"purples\"))\n```\n\n::: {.cell-output-display}\n![Example of two separate maps, one for each variable.](figures/fig-bivariate-scales1-1.png){#fig-bivariate-scales1 fig-align='center' fig-pos='t' width=100%}\n:::\n:::\n\n\nAnother approach is to create a bivariate map, where the two variables are combined into a single map.\nThis is done by representing not only the values of each variable independently but also their interaction using a bivariate color scale.\n@fig-bivariate-scales2 shows an example of a bivariate map, where the population density and the percentage of the population aged 65 and older are combined into a single map.\nAreas with a small population density and a small percentage of the population aged 65 and older are colored in gray, while areas with a high population density and a high percentage of the population aged 65 and older are colored in dark brown.\nAdditionally, the areas with a high population density and a low percentage of the population aged 65 and older are colored in purple, while areas with a low population density and a high percentage of the population aged 65 and older are colored in gold.\n\nThe creation of bivariate maps is done with the `tm_vars()` function, where we specify the two variables we want to combine and set the `multivariate` argument to `TRUE`.\nBivariate maps also require a special color palette, which can be specified with `tm_scale_bivariate()` provided to the `*.scale` argument.\n<!-- advice regarding color palettes? -->\nAdditionally, we can modify the `*.legend` argument with `tm_legend_bivariate()`.\nIn the case of bivariate maps, the `xlab` and `ylab` arguments are used to add labels to the x and y axes of the legend, respectively.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_regions) +\n  tm_polygons(fill = tm_vars(c(\"pop_dens\", \"pop65perc\"), multivariate = TRUE),\n              fill.scale = tm_scale_bivariate(values = \"purplegold\"),\n              fill.legend = tm_legend_bivariate(xlab = \"Pop. 65+ %\", \n                                                ylab = \"Pop. density\\n(per sq. km)\"))\n```\n\n::: {.cell-output-display}\n![Example of a bivariate map, where two variables are combined into a single map.](figures/fig-bivariate-scales2-1.png){#fig-bivariate-scales2 fig-align='center' fig-pos='t' width=100%}\n:::\n:::\n\n\nThe map of a relationship between two variables can also be done for raster data, such as `SpatRaster` and `stars` objects.\nBelow, we read the monthly average temperature for Slovenia from a GeoTIFF file and then select only the two months of interest -- January and July.\nOur aim is to visualize how winter and summer temperatures differ in Slovenia.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(terra)\nslo_tavg = rast(\"data/slovenia/slo_tavg.tif\") \nslo_tavg = slo_tavg[[c(1, 7)]] # select only January and July\n```\n:::\n\n\nAs you can see below, the syntax to create a bivariate map using `tm_vars()` is the same as for vector data, except in this case, we use `tm_raster()` instead of `tm_polygons()` (@fig-tmrastbiv-1).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_tavg) +\n  tm_raster(col = tm_vars(x = c(\"tavg_1\", \"tavg_7\"), multivariate = TRUE))\n```\n:::\n\n\nOne important difference between a regular map and a bivariate map is that the latter is based on two scales -- and we are able to specify them separately.\nThus, all of the scales from sections [-@sec-categorical-scales] to [-@sec-continuous-scales] can be used for bivariate maps, and we may use one of them for each variable.\nIn the example below, we use two scales for the temperature -- one for the January temperatures and one for the July temperatures.\nIn both cases, our scales are intervals, but we customize their breaks and add text labels.\n\nAnother difference is that a regular color scale is one-dimensional -- it has only one axis, and thus we can either use its original form (e.g., from light to dark blue) or flip it (e.g., from dark to light blue).\nA bivariate color scale, on the other hand, is two-dimensional.\nIt has two axes, and this opens up many more possibilities for modifying the scale.\nIn the example below, we are using the `\"pinkblue\"` color scale, which, by default, features a gray color at the bottom left, with the vertical axis transitioning to purple and the horizontal axis transitioning to green.\nThe colors mix in the top right corner to form a dark blue.\nHowever, in our case, we may consider flipping this color scale along the main diagonal, so that the vertical axis transitions to green, while the horizontal one transitions to purple.\nThis seems more intuitive, as the vertical axis represents January temperatures, which are typically colder than July temperatures in Slovenia.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(slo_tavg) +\n  tm_raster(col = tm_vars(c(\"tavg_1\", \"tavg_7\"), multivariate = TRUE),\n            col.scale = tm_scale_bivariate(\n              values = \"//pinkblue\",\n              scale1 = tm_scale_intervals(\n                breaks = c(-8, -4, 0, 4, 8), \n                labels = c(\"Very cold\", \"Cold\", \"Mild\", \"Warm\")\n              ),\n              scale2 = tm_scale_intervals(\n                breaks = c(5, 10, 15, 20, 25),\n                labels = c(\"Very cold\", \"Cold\", \"Mild\", \"Warm\")\n              )\n            ),\n            col.legend = tm_legend_bivariate(\n              xlab = \"July\", ylab = \"January\", reverse = FALSE\n            )\n          )\n```\n:::\n\n\n@fig-tmrastbiv-2 shows a customized bivariate map for the January and July temperatures in Slovenia.\nWe may see that most of the country is characterized by mild temperatures in both months, while the cold temperatures are observed in the mountainous regions in the northwest, and the warm temperatures are observed in the southwest part of the country.\nThere are also a few areas where the temperature category is very different between the two months, such as the northeastern part of the country, with warm July and cold January temperatures.\n\n\n::: {#fig-tmrastbiv .cell layout-ncol=\"1\" layout-align=\"center\"}\n::: {.cell-output-display}\n![simple map](figures/fig-tmrastbiv-1.png){#fig-tmrastbiv-1 fig-align='center' fig-pos='t' width=100%}\n:::\n\n::: {.cell-output-display}\n![customized map](figures/fig-tmrastbiv-2.png){#fig-tmrastbiv-2 fig-align='center' fig-pos='t' width=100%}\n:::\n\nBivariate maps for raster data.\n:::\n\n\n<!-- https://github.com/cols4all/cols4all-R/issues/45 -->\n\nAll possible flipping operators for bivariate color scales are shown in @tbl-flipops-table.\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n::: {#tbl-flipops-table .cell layout-align=\"center\" tbl-cap='Operators for flipping bivariate color scales'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Operator </th>\n   <th style=\"text-align:left;\"> Description </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\">  </td>\n   <td style=\"text-align:left;\"> Normal order </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> - </td>\n   <td style=\"text-align:left;\"> Flip columns (left-right) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> | </td>\n   <td style=\"text-align:left;\"> Flip rows (top-bottom) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> + </td>\n   <td style=\"text-align:left;\"> Flip rows and columns </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> // </td>\n   <td style=\"text-align:left;\"> Flip main diagonal (top-left to bottom-right) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> \\\\  </td>\n   <td style=\"text-align:left;\"> Flip other diagonal (top-right to bottom-left) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> -// </td>\n   <td style=\"text-align:left;\"> Flip main diagonal and columns </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> -\\\\ </td>\n   <td style=\"text-align:left;\"> Flip other diagonal and columns </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nAdditionally, @fig-tmo-bivariate shows how these flipping operators work in action on an example bivariate color scale.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Bivariate color scales with different flipping operators](figures/fig-tmo-bivariate-1.png){#fig-tmo-bivariate fig-align='center' fig-pos='t' width=100%}\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}