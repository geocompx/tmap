{
  "hash": "f170f584013850800d9ba82b11b8be77",
  "result": {
    "engine": "knitr",
    "markdown": "\n::: {.cell}\n\n:::\n\n\n# Specifying spatial data {#sec-tmshape}\n\nAt least two aspects need to be specified in order to plot spatial data: the spatial data object itself and the plotting method(s). \nWe will cover the former in this chapter. \nThe latter will be discussed in the next chapters.\n\n## Shapes and layers {#sec-shapes-and-layers}\n\nAs described in @sec-geodata, shape objects can be vector or raster data.\nWe recommend `sf` objects for vector data and `stars` objects for raster data^[However, **tmap** also accepts other spatial objects, e.g., of `sp`, `raster`, and `terra` classes.].\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tmap)\nlibrary(sf)\nlibrary(stars)\nworldelevation = read_stars(\"data/worldelevation.tif\")\nworldvector = read_sf(\"data/worldvector.gpkg\")\nworldcities = read_sf(\"data/worldcities.gpkg\")\n```\n:::\n\n\nIn **tmap**, a shape object needs to be defined with the function `tm_shape()`.\nWhen multiple shape objects are used, each has to be defined in a separate `tm_shape()` call.\nThis is illustrated in the following example (@fig-tmshape1).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(worldelevation) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = terrain.colors(8))) +\n  tm_shape(worldvector) +\n  tm_borders() +\n  tm_shape(worldcities) +\n  tm_dots() +\n  tm_text(\"name\")\n```\n\n::: {.cell-output-display}\n![A map representing three shapes (worldelevation, worldvector, and worldcities) using four layers.](figures/fig-tmshape1-1.png){#fig-tmshape1 fig-align='center' width=100%}\n:::\n:::\n\n\nIn this example, we use three shapes: `worldelevation` which is a `stars` object containing an attribute called `\"worldelevation.tif\"`, `worldvector` which is an `sf` object with country borders, and `worldcities` -- an `sf` object that contains metropolitan areas of at least 20 million inhabitants.\n\nEach `tm_shape()` function call is succeeded by one or more layer functions.\nIn the above example, these are `tm_raster()`, `tm_borders()`, `tm_dots()` and `tm_text()`.\nWe will describe layer functions in detail in the next chapter.\nFor this chapter, it is sufficient to know that each layer function call defines how the spatial data specified with `tm_shape()` is plotted.\n\nShape objects can be used to plot multiple layers.\nIn the example, shape `worldcities` is used for two layers, `tm_dots()` and `tm_text()`.\n\n## Shapes hierarchy {#sec-shapes-hierarchy}\n\nThe order of the `tm_shape()` functions' calls is crucial.\nThe first `tm_shape()`, known as *the main shape*, is not only shown below the following *shapes*, but also sets the projection and extent of the whole map.\nIn @fig-tmshape1, the `worldelevation` object was used as the first *shape*, and thus the whole map has the projection and extent of this object.\n\nHowever, we can quickly change the main *shape* with the `is.main` argument.\nIn the following example, we set the `worldcities` object as the main *shape*, which limits the output map to the point locations in `worldcities` (@fig-tmshape2)^[We will show how to adjust margins and text locations later in the book].\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(worldelevation) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = terrain.colors(8))) +\n  tm_shape(worldvector) +\n  tm_borders() +\n  tm_shape(worldcities, is.main = TRUE) +\n  tm_dots() +\n  tm_text(\"name\")\n```\n\n::: {.cell-output-display}\n![A map representing three shapes (worldelevation, worldvector, and worldcities) using four layers and zoomed into the locations in the worldcities object.](figures/fig-tmshape2-1.png){#fig-tmshape2 fig-align='center' width=100%}\n:::\n:::\n\n\n## Map extent {#sec-map-extent}\n\nAnother important aspect of mapping, besides projection, is its extent -- a portion of the area shown in a map.\n<!--add info about the bounding box term-->\nThis is not an issue when the extent of our spatial data is the same as we want to show on a map.\nHowever, what should we do when the spatial data contains a larger region than we want to present?\n\nAgain, we could take two routes.\nThe first one is to preprocess our data before mapping - this can be done with vector clipping (e.g., `st_intersection()`) and raster cropping (e.g., `st_crop()`).\nWe would recommend this approach if you plan to work on the smaller data in the other parts of the project.\nThe second route is to specify the map extent in **tmap**.\n\n**tmap** allows specifying map extent using three approaches.\nThe first one is to specify minimum and maximum coordinates in the x and y directions that we want to represent.\nThis can be done with a numeric vector of four values in the order of minimum x, minimum y, maximum x, and maximum y, where all of the coordinates need to be specified in the input data units^[This can also be done with the object of class `st_bbox` or a 2 by 2 matrix.]\nIn the following example, we limit our map extent to the rectangular area between x from -15 to 45 and y from 35 to 65 (@fig-tbbox1).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(worldelevation, bbox = c(-15, 35, 45, 65)) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = terrain.colors(8)))\n```\n\n::: {.cell-output-display}\n![Global elevation data limited to the extent of the specified minimum and maximum coordinates.](figures/fig-tbbox1-1.png){#fig-tbbox1 fig-align='center' width=100%}\n:::\n:::\n\n\nThe second approach allows for the map to be set to an extent based on a search query.\nIn the code below, we limit the map extent to the area of `\"Europe\"` (@fig-tbbox2).\nThis approach uses the OpenStreetMap tool called Nominatim to automatically generate minimum and maximum coordinates in the x and y directions based on the provided query.\n<!-- add refs/links -->\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(worldelevation, bbox = \"Europe\") +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = terrain.colors(8)))\n```\n\n::: {.cell-output-display}\n![Global elevation data limited to the extent specified with the 'Europe' query.](figures/fig-tbbox2-1.png){#fig-tbbox2 fig-align='center' width=100%}\n:::\n:::\n\n\nIn the last approach, the map extent is based on another existing spatial object.\n@fig-tbbox3 shows the elevation raster data (`worldelevation`) limited to the edge coordinates from `worldcities`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(worldelevation, bbox = worldcities) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = terrain.colors(8)))\n```\n\n::: {.cell-output-display}\n![Global elevation data limited to the extent of the other spatial object.](figures/fig-tbbox3-1.png){#fig-tbbox3 fig-align='center' width=100%}\n:::\n:::\n\n\n<!-- mention that legend related to the complete object -->\n<!-- ?bb -->\n<!-- explain some additional arguments of bb?? -->\n\n## Map projection {#sec-map-projection}\n\\index{map projection}\n\nAs we mentioned in the previous section, created maps use the projection from the main *shape*.\nHowever, we often want to create a map with a different projection, for example, to preserve a specific map property (@sec-crs).\nWe can do this in three ways.\nThe first way to use a different projection on a map is to reproject the main data before plotting, as shown in @sec-crs-in-r.\nThe second way is to specify the map projection using the `crs` argument of `tm_shape()`.\nThis argument expects either some `crs` object or a CRS code.\nThe third way is to use a `tm_crs()` function.\n\nThe next code chunks shows all of the three ways, in which we transform the CRS of the `worldvector` object to `\"EPSG:8857\"`.\nThis represents a projection called [Equal Earth](http://equal-earth.com/index.html) [@savric_equal_2019].\nThe Equal Earth projection is an equal-area pseudocylindrical projection for world maps similar to the non-equal-area Robinson projection (@fig-crs-robin).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#1\nworldvector8857 = st_transform(worldvector, crs = \"EPSG:8857\")\ntm_shape(worldvector8857) +\n  tm_polygons()\n#2\ntm_shape(worldvector, crs = \"EPSG:8857\") +\n  tm_polygons() \n#3\ntm_shape(worldvector) +\n  tm_polygons() +\n  tm_crs(\"EPSG:8857\")\n```\n:::\n\n\nThe first way requires understanding various R packages, as different spatial objects have different functions for changing the projection.\nThe second way is the most straightforward, but it is important to remember that the `crs` argument can only be set in the main layer (@sec-shapes-hierarchy).\nThe third way is the most flexible, as it allows changing the projection for the whole map.\nAdditionally, the `tm_crs()` function can automatically determine the projection based on the expected property of the map, e.g., equal area (`\"area\"`), equidistant (`\"distance\"`), or conformal (`\"shape\"`).\nFor example, `tm_crs(\"auto\")` will choose the projection that best preserves the area of the map (*Lambert Azimuthal Equal Area*), while `tm_crs(\"auto\", property = \"shape\")` will choose the projection that best preserves the shape of the map (*Stereographic*).\n\nReprojections of vector data are usually straightforward because each spatial coordinate is reprojected individually.\n<!-- mention invalid geometries? -->\nReprojecting of raster data, on the other hand, is more complex and requires using one of two approaches.\nThe first approach applies raster warping, which is a name for two separate spatial operations: creation of a new regular raster object and computation of new pixel values through resampling (for more details read Chapter 7 of @lovelace_geocomputation_2025).\nThis is the default option in **tmap**, however, it has some limitations and it is not always possible to use it.\n\n<!-- to fix the rest of the section! -->\n@fig-tm-map-proj-1 shows the world elevation raster reprojected to Equal Earth.\nSome of you can quickly notice that certain areas, such as parts of Antarctica, New Zealand, Alaska, and the Kamchatka Peninsula, are presented twice, with one version being largely distorted.\nAnother limitation of `raster.warp = TRUE` is the use of the nearest neighbor resampling only -- while it can be a proper method to use for categorical rasters, it can have some unintended consequences for continuous rasters (such as the `\"worldelevation.tif\"` data).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(worldelevation) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = terrain.colors(8))) +\n  tm_crs(\"EPSG:8857\")\n```\n:::\n\n\nThe second approach (`tm_options(raster.warp = FALSE)`) computes new coordinates for each raster cell keeping all of the original values and results in a curvilinear grid.\nThis calculation could deform the shapes of original grid cells, and usually curvilinear grids take a longer time to plot^[For more details of the first approach, see `?stars::st_warp()` and of the second approach, see `?stars::st_transform()`.].\n\n@fig-tm-map-proj-2 shows an example of the second approach, which gave a better result in this case without any spurious lands.\nHowever, the creation of the (b) map takes about ten times longer than the (a) map.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntm_shape(worldelevation) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = terrain.colors(8))) +\n  tm_crs(\"EPSG:8857\") +\n  tm_options(raster.warp = FALSE)\n```\n:::\n\n\n\n::: {#fig-tm-map-proj .cell layout-nrow=\"2\" layout-align=\"center\"}\n::: {.cell-output-display}\n![created using raster.warp = TRUE](figures/fig-tm-map-proj-1.png){#fig-tm-map-proj-1 fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![created using raster.warp = FALSE](figures/fig-tm-map-proj-2.png){#fig-tm-map-proj-2 fig-align='center' width=100%}\n:::\n\nTwo elevation maps in the Equal Earth projection\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n<!-- add our recommendations -->\n<!-- about reprojecting first vs later - why and how -->\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}