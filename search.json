[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatial Data Visualization with tmap",
    "section": "",
    "text": "Welcome\nWelcome to the online home of Spatial Data Visualization with tmap: A Practical Guide to Thematic Mapping in R. This book is a hands-on, open-source resource for anyone interested in creating maps using R and the tmap package.\nWhether you’re a beginner in geospatial analysis or an experienced GIS user transitioning to R, this book will help you learn how to visualize spatial data for print, the web, and interactive applications.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#what-youll-learn",
    "href": "index.html#what-youll-learn",
    "title": "Spatial Data Visualization with tmap",
    "section": "What you’ll learn",
    "text": "What you’ll learn\nThis book walks you through the full process of thematic mapping with tmap, including:\n\nLoad, explore, and prepare spatial data in R\nBuild maps using tmap’s core components like shapes, layers, and visual variables\nCustomize map appearance with legends, scales, layouts, and annotations\nCreate faceted, animated, and interactive maps for various audiences\nIntegrate tmap maps into reports, web apps, and Shiny dashboards\nExtend tmap by adding new map layer types, spatial data classes, and output modes\nApply good design practices to make maps that are clear, consistent, and effective\n\nEach chapter combines concise explanations, reproducible code, and real-world examples.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#how-to-contribute",
    "href": "index.html#how-to-contribute",
    "title": "Spatial Data Visualization with tmap",
    "section": "How to contribute",
    "text": "How to contribute\nWe welcome your contributions to make this book better!\nYou can help by:\n\nSuggesting topics or reporting issues via the issue tracker\n\nFixing typos or improving clarity\nEnhancing code examples or adding new ones\n\nAll contributions are appreciated and acknowledged.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "Spatial Data Visualization with tmap",
    "section": "Citation",
    "text": "Citation\nIf you use this book in your work, please cite it as:\n\nTennekes M., Nowosad J. (2025) Spatial Data Visualization with tmap: A Practical Guide to Thematic Mapping in R. Available at: https://tmap.geocompx.org",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Spatial Data Visualization with tmap",
    "section": "License",
    "text": "License\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivs 4.0 International License.\n\nThe code samples in this book are licensed under a Creative Commons CC0 1.0 Universal (CC0 1.0) Public Domain Dedication.\n\nThis version of the book was built on 2025-07-17.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 What is tmap?\nThis book teaches how to make elegant and informative maps with the R-package tmap. A couple of real-world applications are used to illustrate the whole process, from exploring raw spatial data to presenting insightful results.\nWe can distinguish three aspects that are required to make good maps:\nThe main focus of this book will be on software skills, since our aim is to create maps with tmap. Along the way, we will cover the most important data visualization methodology. Since whole books have been written about it already, we will keep this brief and pragmatic. Obviously, it is not possible to cover the remaining aspect, domain knowledge. However, the example datasets do not require much specific domain knowledge.\nThe short answer is that tmap is an R package for the visualization of spatial data. The slightly longer answer is that tmap allows users to explore, analyze, and present spatial data in an intuitive way. In this book, you will find the long answer.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#prerequisites",
    "href": "intro.html#prerequisites",
    "title": "1  Introduction",
    "section": "\n1.2 Prerequisites",
    "text": "1.2 Prerequisites\n\n\nTo follow all the examples in this book, you’ll need to install the tmap package along with a few additional dependencies. The easiest way to do this is by installing the tmapbook package:\ninstall.packages(\"tmapbook\", repos = c(\"https://geocompx.r-universe.dev\",\n                                       \"https://cloud.r-project.org\"))\nAll datasets used in the book are hosted in the tmapdata repository. You can download them using the usethis package:\nusethis::use_course(\"geocompx/tmapdata\")",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "geodata.html",
    "href": "geodata.html",
    "title": "2  Spatial data in R",
    "section": "",
    "text": "2.1 Introduction\nVector and raster data models are two basic models used to represent spatial data. These spatial data models are closely related to map making, with each model having its own pros and cons.    This chapter starts by describing these two popular spatial data models, and their extensions, spatial vector and raster data cubes (Section 2.2). Each data model is introduced, explained how it is built, and how it is stored using different file formats. Next, this chapter presents how these different data models are implemented in R (Section 2.3). It includes showing how to read different spatial data formats, how to understand spatial R objects, and where to find more information about preprocessing spatial data.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Spatial data in R</span>"
    ]
  },
  {
    "objectID": "geodata.html#sec-data-models",
    "href": "geodata.html#sec-data-models",
    "title": "2  Spatial data in R",
    "section": "\n2.2 Data models",
    "text": "2.2 Data models\nTraditionally, spatial data is described by two basic data models: vector data model aimed at (Section 2.2.1) representing the world using points, lines, and polygons, and raster data model focused on representing surfaces (Section 2.2.2). Additionally, now we have an abundance of available spatial data and a variety of ways to obtain it. It includes having many district variables and repeated measurements for the same area. Therefore, we also present the concept of spatial data cubes (Section 2.2.3).\n\n2.2.1 Vector data model\n The vector data model represent the world as a set of spatial geometries with non-spatial attributes (Figure 2.1). The role of geometry is to describe the location and shape of spatial objects. Attributes, on the other hand, are used to store the properties of the data.\n There are three basic types of geometries: points, lines, and polygons, all of them are made up of coordinates (left part of Figure 2.1). A point is represented by a pair of coordinates, usually described as X and Y, allowing for locating this point in some space. X and Y could be unitless, in degrees, or in some measure units, such as meters (extended discussion on coordinates and related topics is in Chapter 13). Points can represent features on different spatial scales, from a GPS position, location of a bench in a park, to a city on a small scale map. They are also used to express abstract features, such as locations of map labels. Properties of points can be expressed on maps by different point sizes, colors, or shapes. A line extends the idea of a point. It consists of several points with coordinates (called vertices) that are arranged in some order. Consecutive points are connected by straight lines. Therefore, a straight spatial line consists of two points (two pairs of coordinates), while complex spatial lines could be created based on a large number of points. It gives the illusion that the line is curved. Lines are used to representing linear features, such as roads, rivers, boundaries, footpaths, etc. In this case, we can express line features’ attributes using either lines’ color or their widths.   A polygon is again a set of ordered points (vertices) connected by straight lines. Its only difference from the line is that the first and the last point in a polygon has the same coordinates, and thus close the object.  The polygon representation is used to represent shapes and locations of different objects, from a lake or a patch of vegetation, through a building or a city block, to some administrative units. Polygons also have one unique feature - they could have holes. A polygon hole represents an area inside of the polygon but does not belong to it. For example, a lake with an island can be depicted as a polygon with a hole. The values of polygons’ attributes can be represented by the areas (fill) colors.\n The second part of the vector data model relates to non-spatial attributes (right part of Figure 2.1). Attributes are usually stored as a table, in which each column depicts some property, such as an identification number, a name of a feature, or a value of some characteristic. Each row, on the other hand, relates to a single spatial geometry.\n\n\n\n\n\n\n\nFigure 2.1: Instances of spatial vector data model: POINTS, LINES, and POLYGONS.\n\n\n\n\n The above ideas could be implemented in many ways.  Currently, the Simple Feature Access seems to be the most widely used standard. In it, a feature is every object or concept that have spatial location or extent.\nSimple feature standard makes a clear distinction between single- and multi-element features. We can have a POINT feature and a MULTIPOINT feature, and similarly LINESTRING and MULTILINESTRING, and POLYGON and MULTIPOLYGON. The main difference between single element features (such as POINT or POLYGON) and multi-element features (such as MULTIPOINT or MULTIPOLYGON) can be clearly seen by looking at attribute tables. For example, six points stored as POINT features fill six separate rows, while six points stored as just one MULTIPOINT feature occupy just one row.  Examples of single- and multi-element features can be seen in Figure 2.1. The top example shows point data represented as MULTIPOINT feature: although we have seven points (seven distinct pairs of coordinates), they are gathered into two groups, green and orange, which can be seen in the associated attribute table. The central example, on the other hand, uses single-element features, where each line geometry relates to one row in the attribute table. Finally, the bottom example again uses multi-element features, where the second feature (Country B) consist of two separate geometries. The simple feature standard also describes a number of additional geometry types, including Curve, Surface, or Triangle. Finally, GeometryCollection exists that contains all of the possible geometry types.\n\n\n A couple hundreds of file formats exist to store spatial vector data. One of the simplest ways to store spatial data is in the form of a text file (.csv) or as a spreadsheet (.xls or .xlsx). While it makes storing point data simple, with two columns representing coordinates, it is not easy to store more complex objects in this way. Text files are also not suitable for storing information about the coordinate reference system used (Chapter 13). Historically, the shapefile format (.shp) developed by the ESRI company gained a lot of interest and become the most widely supported spatial vector file format. Despite its popularity, this format has a number of shortcomings, including the need to store several files, attribute names limited to ten characters, the ability to store up to 255 attributes and files up to 2GB, and many more. A fairly recent file format, OGC GeoPackage (.gpkg), was developed as an alternative. It is a single file database free from the limitation of the shapefile format. Other popular spatial vector file formats include GeoJSON (.geojson), GPX (.gpx), and KML (.kml).  \n\n2.2.2 Raster data model\n The raster data model represents the world using a continuous grid of cells, where each cell has a single associated value (Figure 2.2). Depending on the type of values, we can distinguish continuous and categorical rasters. In continuous rasters, such as elevation or precipitation, values vary progressively. Categorical rasters, on the other hand, uses integer values to represent classes. Their examples include land cover or soil types maps. Raster data can also contain cells for which we do not know the value (Figure 2.2). For example, data for this part of the area was not collected, or these locations are outside of our area of interest.\n\n\n\n\n\n\n\n\n\n(a) Cell IDs\n\n\n\n\n\n\n\n\n\n(b) Cell values\n\n\n\n\n\n\n\n\n\n(c) A raster map\n\n\n\n\n\n\nFigure 2.2: Basic representations of the raster data model\n\n\n When we think about raster data, most of the time we are referring to regular grids (Figure 2.3). In regular grids, each cell has the same, constant size, and coordinates change from top to bottom and from left to right1.  Regular rasters can be transformed into rotated and sheared rasters (Figure 2.3). Rotated grids are the result of transforming both coordinated, \\(x\\) and \\(y\\) using the same rotation coefficients. Sheared grids are created when the rotation coefficients are not equal. Rectilinear grids, on the other hand, have orthogonal axes, but consist of rectangular cells with different sizes and shapes (Figure 2.3). In the last type of raster data grids, curvilinear grids, cells are cuboids of different sizes and shapes (Figure 2.3).\n\n\n\n\n\n\n\n\n\n\n(a) Regular\n\n\n\n\n\n\n\n\n\n(b) Rotated\n\n\n\n\n\n\n\n\n\n(c) Sheared\n\n\n\n\n\n\n\n\n\n(d) Rectilinear\n\n\n\n\n\n\n\n\n\n(e) Curvilinear\n\n\n\n\n\n\nFigure 2.3: Main types of raster data grids\n\n\nContrary to spatial vector data, a basic raster data stores just one attribute. It is, however, possible to stack together many single rasters (also known as raster layers). This allows us to store and operate on many rasters having the same dimensions at the same time. Examples of multi-layer rasters include satellite imageries or temporal rasters. Satellite imageries usually consist of many bands (layers) for different wavelengths. The most basic bands, representing the colors red, green, and blue, can be connected together to create one composite image with true colors (Figure 2.4). Temporal rasters store one attribute, but for many moments in time.  Additional information about multi-layer rasters can be also found in Section 2.2.3.\n\n\n\n\n\n\n\n\n\n(a) Red\n\n\n\n\n\n\n\n\n\n(b) Green\n\n\n\n\n\n\n\n\n\n(c) Blue\n\n\n\n\n\n\n\n\n\n(d) Composite\n\n\n\n\n\n\nFigure 2.4: Example of three satellite imagery bands: red, green, blue, and the composite image with true colors created using these three bands.\n\n\n Similarly to vector data, a large number of raster file formats exists.  Currently, the GeoTIFF format (.tif or .tiff) is one of the most popular spatial raster formats. It is an extended image TIF format that stores spatial metadata (e.g., map projection) along the values. Another popular spatial raster formats include Arc ASCII (.asc) and ERDAS Imagine (.img). \n\n2.2.3 Spatial data cubes\n Traditionally, spatial vector and raster data models refer to a unique set of locations. For example, each feature in a polygon dataset and each cell in a raster dataset refer to one specific area. However, to solve real-life problems, we need to store and operate on more complex data structures. It includes situations when we have many attributes, often for several moments in time.\n Storing multiple attributes is not a problem for the vector data model, when an attribute table can have many columns. The question is how to extend the spatial vector data model to include measurements for many times. For example, let’s consider a polygon data with many attributes representing shares of land-use types for several years (Figure 2.5). One approach would be to create a separate column for each variable in each year. Alternatively, we can have one column representing the year and one column for each attribute, however, this approach would require multiplying each geometry as many times as we have time stamps.  The third approach involves separating geometries from attributes, and where attributes for each moment are stored independently. The last idea is used in spatial vector data cubes (Section 2.3.3). An example of the spatial vector data cubes idea can be seen in Figure 2.5. It consists of two elements: a geometry (MULTIPOLYGON) of provinces of the Netherlands and an array connected to it that stores shares of land-use types for several years.\n\n\n\n\n\n\n\nFigure 2.5: Vector data cube.\n\n\n\n\n A single raster dataset can store just one variable for a given area. To store several attributes, we can connect rasters representing different attributes for the same extent, creating multi-layer rasters (Section 2.2.2). Additionally, each of the aforementioned rasters can be collected for many moments in time, adding other layers to the data.  The question here is how to efficiently store multi-layer raster data to understand what layers relate to which attribute and time. Similarly to spatial vector data cubes, we can think of separating spatial dimensions from non-spatial attributes and create spatial raster data cubes (Section 2.3.3). Figure 2.6 gives an example of a raster data cube. It consists of several single-layer rasters with the same spatial properties, such as resolution, extent, and CRS. These rasters are organized to store four-dimensions of the data: latitude, longitude, time, and attributes. It has values of three attributes for five moments in time in total.\n\n\n\n\n\n\n\nFigure 2.6: Raster data cube.\n\n\n\n\nSpatial data cubes are suitable for many real-life applications. For example, time-series of climate measurements for several stations, demographic data on a country level gathered for many years, or satellite imageries over some period of time.\n One way to create spatial data cubes is by connecting many independent vector or raster objects.  Second way is to read a spatial data cube from one of the file formats allowing for storing complex data. It includes formats such as NetCDF (.nc) and HDF (.hdf).",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Spatial data in R</span>"
    ]
  },
  {
    "objectID": "geodata.html#sec-spatial-data-representations-in-r",
    "href": "geodata.html#sec-spatial-data-representations-in-r",
    "title": "2  Spatial data in R",
    "section": "\n2.3 Spatial data representations in R",
    "text": "2.3 Spatial data representations in R\n R has several packages aimed to represent spatial vector data.  For more than a decade, the sp package  was a standard of vector data representation in R. However, now this package is in the maintenance mode only, and its successor, sf is recommended. The tmap package has been using sf since version 2.0.\n Several R packages can be used to represent spatial raster data, including raster and its successor terra. The raster package was used as a backbone of raster data visualization until tmap version 3.0. Currently, the terra package’s raster objects can be used in tmap. Additionally, the stars package is used by tmap to operate on raster data and spatial data cubes.\nIn the three next sections, we introduce the sf package (Section 2.3.1), the terra (Section 2.3.2), the stars package (Section 2.3.3).\n\n\n\n\n2.3.1 The sf package\n \nThe sf package implements ideas behind the Simple Feature standard, which describe how to represent spatial vector data. Its main class, sf, has the form of an extended data frame, where each row is a spatial feature. In it, attributes of the vector data are stored as columns. It also has one additional column, most often named geom or geometry2. This column contains geometries in a form of well-known text (WKT), storing all of the coordinates.\n\nThe sf package can read all of the spatial data formats mentioned in Section 2.2.1 using the read_sf() function3. \n\nlibrary(sf)\nworldvector = read_sf(\"data/worldvector.gpkg\")\n\nThe new object, worldvector, has a sf class. It has 185 features (rows or geometries) and 15 fields (columns with attributes). There is also an 16th column, geom, that stores geometries of each feature. Objects of class sf also display a header containing spatial metadata. It includes geometry type, dimension (XY, XYZ, XYM, XYZM), bounding box (bbox), and information about the used Coordinate Reference System (CRS).\n\nworldvector\n\nSimple feature collection with 185 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -16331900 ymin: -8392908 xmax: 16886150 ymax: 8315884\nProjected CRS: WGS 84 / Equal Earth Greenwich\n# A tibble: 185 × 16\n   GEO   name    wb_region wb_income_region population CO2_emissions gdp_per_cap\n   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;                 &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;\n 1 AUS   Austra… East Asi… High income        42900000       15.3          56800\n 2 AZE   Azerba… Europe &… Upper middle in…    9190000        3.94          5770\n 3 BIH   Bosnia… Europe &… Upper middle in…    1640000        6.38          6030\n 4 BGD   Bangla… South As… Lower middle in…  151000000        0.474         1200\n 5 BEL   Belgium Europe &… High income        12500000        8.32         47200\n 6 BFA   Burkin… Sub-Saha… Low income         83200000        0.162          712\n 7 BGR   Bulgar… Europe &… Upper middle in…    3590000        5.85          8650\n 8 BDI   Burundi Sub-Saha… Low income         50900000        0.0447         211\n 9 BEN   Benin   Sub-Saha… Low income         47200000        0.614          897\n10 BRN   Brunei  East Asi… High income          390000       22.2          31400\n# ℹ 175 more rows\n# ℹ 9 more variables: life_expectancy &lt;dbl&gt;, corruption_perception_index &lt;dbl&gt;,\n#   democracy_score &lt;dbl&gt;, hdi &lt;dbl&gt;, energy_use_per_cap &lt;dbl&gt;,\n#   literacy_rate &lt;dbl&gt;, demo_corr &lt;dbl&gt;, demo_corr_rank &lt;int&gt;,\n#   geom &lt;MULTIPOLYGON [m]&gt;\n\n\nThe worldvector object has MULTIPOLYGON geometry type, where each feature (row) can consist of one or more polygons. Each polygon’s vertices are represented by a pair of values (dimension: XY). Bounding box allows to quickly understand the spatial extension of the input data.  Finally, it has projected CRS named WGS 84 / Equal Earth Greenwich. You can learn more about Coordinate Reference Systems in Chapter 13. \nSpatial vector data of class sf can be also obtained using some of other R data packages.  For example, rnaturalearth allows to download world map data, osmdata imports OpenStreetMap data as sf objects, and tigris loads TIGER/Line data.  \nThe tmap package accepts spatial vector data objects from both sf and sp packages. In case of having vector objects in a different representation, they should be converted into sf objects first, before making maps. The sf package has the st_as_sf() function that translates objects of many classes, including Spatial (from the sp package), ppp, psp, and lpp (from the spatstat package), to the objects of class sf. The st_as_sf() function also allows to turn data frames into sf objects - the user needs to provide the input data frame, names of columns with coordinates, and additionally definition of the CRS of the data. For example my_sf = st_as_sf(my_df, coords = c(\"Xcolumn\", \"Ycolumn\"), crs = \"EPSG:4326\").\nIf you want to learn more about operating on sf objects, we recommend visiting the package website and vignettes at https://r-spatial.github.io/sf/ and reading the Geocomputation with R book (Lovelace, Nowosad, and Muenchow 2025). \n\n2.3.2 The terra package\n \nThe terra package represents and processes spatial raster data in R. It has many high-performance functions, allowing for efficient transformation and analysis of raster data.\nTo read raster data, the terra package has the rast() function4. This way, we create a new object of the class SpatRaster, which is the main class for raster data in the terra package.\n\nlibrary(terra)\nworldelevation1 = rast(\"data/worldelevation.tif\")\n\nTo see the properties of the worldelevation1 object, we just need to type its name.\n\nworldelevation1\n\nclass       : SpatRaster \nsize        : 540, 1080, 1  (nrow, ncol, nlyr)\nresolution  : 0.3333333, 0.3333333  (x, y)\nextent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : worldelevation.tif \nname        : worldelevation \n\n\nNow, we can see the number of rows and columns, resolution, extent, coordinate reference system (CRS), and the source and name of the raster layer. In the case of raster data from a file, the terra package uses a proxy approach, where only metadata is read into computer memory, and the actual values are read only when needed and processed in fitting-in-memory chunks.\nThe terra package has many functions for raster data processing, including merge(), aggregate(), resample(), and many more. It also enables interactions between raster and vector data, including cropping rasters to vector geometries and masking rasters with vector geometries using the crop() and mask() functions, respectively. \nPractical examples of using the terra package can be found on the Spatial Data Science with R and “terra” website and in the Geocomputation with R book (Lovelace, Nowosad, and Muenchow 2025).\n\n2.3.3 The stars package\n \n\nThe stars package allows for reading and processing raster data in R. This package also has support for both spatial vector and raster data cubes. Its main class, stars, is built as a list of matrices or arrays with metadata describing their dimensions. The stars package is also well integrated with sf, with many st_ functions (such as st_crs()) working also on stars objects.\n\nThe read_stars() function allow to read both simple and multidimensional spatial raster data from a file5. This function requires at least one argument with a filename to be read. \n\nlibrary(stars)\nworldelevation2 = read_stars(\"data/worldelevation.tif\")\n\nThe new object, worldelevation2, is of a stars class. It has two dimensions, x and y, and one attribute worldelevation.tif.\n\nworldelevation2\n\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n                    Min. 1st Qu. Median     Mean 3rd Qu. Max.   NA's\nworldelevation.tif  -412     218    608 1139.982    1941 6410 389580\ndimension(s):\n  from   to offset   delta refsys point x/y\nx    1 1080   -180  0.3333 WGS 84 FALSE [x]\ny    1  540     90 -0.3333 WGS 84 FALSE [y]\n\n\nThe worldelevation.tif attribute is a matrix, where each cell represents an elevation value. The x dimension has 1080 elements (columns), starting from a coordinate (offset) of a cell boundary of -180. Next, the coordinates of further cells increase by 0.333333 (delta) – resolution in the x dimension. The y dimension has 540 elements (rows), starting from a coordinate (offset) of a cell boundary of 90. For the y dimension, each further cell’s coordinated decreases by 0.333333 (notice the negative value of delta) – resolution in the y dimension. Both dimensions also have the same CRS – WGS 84.\nread_stars() also has several additional arguments including RasterIO, which gives control over the input data extent and resolution. For example, the below code will read just the first and second bands – in this case, the average montly temperatures for January and February in Slovenia (results not shown).  \n\nslo_tavg_fp = \"data/slovenia/slo_tavg.tif\"\nslo_tavg12 = read_stars(slo_tavg_fp, RasterIO = list(bands = c(1, 2)))\n\nInternally, a stars object is a list of matrix or array objects with additional attributes describing spatial metadata, such as a number of columns and rows, resolution, coordinate reference system, etc. All of this information is read from the input file.\nStars objects are constructed by dimensions and attributes. Dimensions relate to what kind of objects are stored as list elements. For example, when it is a matrix then we just have two dimensions representing columns and rows. However, it is also possible to store multidimensional arrays, which allow having many additional dimensions for bands, times, etc. Attributes, on the other hand, are stored as list elements. Each attribute can relate, for example to a different variable.\nReading a simple GeoTIFF file would result in having just two dimensions and one attribute (a matrix). On the other hand, reading complex raster file formats, such as NetCDF could result in having more than two dimensions (e.g. time) and many attributes (e.g., an array with temperature, precipitation, humidity). \n\n\nBefore reading the file, the stars package checks if the input data is a curvilinear grid and what is the number of cells in the data. When the input data is small or curvilinear then the full data is read in computer memory. Otherwise, a stars proxy approach is used, where only metadata is read including pointers to where the complete data is. When we want to plot large raster data, then it is read at a lower resolution than the native one. \nThe stars package also has support for vector data cubes, where each geometry is just stored once (as a dimension), and each attribute is a matrix or an array with the number of rows equals to the number of geometries, the number of columns equals to another dimension (e.g., time), and possibly the number of array layers equals for additional dimensions.  \n\nMore information on how the stars objects are organized and how to operate on them can be found in the stars package vignettes at https://r-spatial.github.io/stars. \n\n\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2025. Geocomputation with R. Second. CRC Press.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Spatial data in R</span>"
    ]
  },
  {
    "objectID": "geodata.html#footnotes",
    "href": "geodata.html#footnotes",
    "title": "2  Spatial data in R",
    "section": "",
    "text": "Regular grids can also have coordinated changing in different directions, e.g., from bottom to top.↩︎\nHowever, any other names are also possible.↩︎\nIt is also possible to read spatial vector data using the st_read() function, which differs from read_sf() by having different default arguments.↩︎\nThis function can also be used to create a new raster from scratch↩︎\nThe stars package also has a function read_ncdf() aimed at improved reading of NetCDF files.↩︎",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Spatial data in R</span>"
    ]
  },
  {
    "objectID": "nutshell.html",
    "href": "nutshell.html",
    "title": "3  tmap in a nutshell",
    "section": "",
    "text": "3.1 Shape objects\nThe tmap package allows the creation of thematic maps with great flexibility. It accepts spatial data in various formats – shape objects (Section 3.1) Next, the data can be used to create simple, quick maps (Section 3.2) and more complex and expandable maps (Section 3.3). These maps can be presented in two modes: as a static map and an interactive one. Additionally, tmap makes it possible to create facet maps (Section 3.4) and map animations (Section 3.5). Finally, tmap has an interactive mode (Section 3.6) that allows users to zoom in and out, pan the map, or click on map objects to get more information – this can be done without any additional code. The goal of this chapter is to provide a brief overview of the main tmap features.\nAs we established in Chapter 2, spatial data comes in various file formats related to two main data models – vector and raster. There are also several spatial object classes in R, for example, sf from the sf package for vector data and stars from stars for raster data and spatial data cubes. Additionally, packages such as sp, raster, or terra offer their own classes, and this abundance of spatial object classes can be generally overwhelming. Gladly, tmap can work with all of the above objects – it treats all supported spatial data classes as so-called shape objects.\nFor example, we read the slo_cities.gpkg file containing several point locations representing cities and towns in Slovenia into a new object, slo_cities. The slo_cities object is a shape object.\nlibrary(tmap)\nlibrary(sf)\nslo_cities = read_sf(\"data/slovenia/slo_cities.gpkg\")\nSpatial data, no matter the class, usually stores two interrelated sets of information - about the locations/geometries and their associated values/attributes. Visualization of the attributes only can be done with regular plotting functions (e.g., plot(), hist(), barplot()) or dedicated packages, such as ggplot2 . On the other hand, tmap is suitable when our goal is to visualize spatial geometries only or spatial geometries together with their attributes.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>**tmap** in a nutshell</span>"
    ]
  },
  {
    "objectID": "nutshell.html#sec-quick-maps",
    "href": "nutshell.html#sec-quick-maps",
    "title": "3  tmap in a nutshell",
    "section": "\n3.2 Quick maps",
    "text": "3.2 Quick maps\nThe tmap package offers a distinction between quick and regular maps. The first approach, using the qtm() function, could be handy for data exploration. It works even if we just provide any shape object – in that case, only the geometry is plotted. Figure 3.1 (a) shows a visualization of the geometries from the slo_cities.\n\nqtm(slo_cities)\n\nThe qtm() function allows to customize many map elements for the provided shape object. For example, we can change the shapes of the points in slo_cities, make their sizes related to the the \"population\" argument, and add a title (Figure 3.1 (b)).\n\nqtm(slo_cities, shape = 24, size = \"population\", title = \"Cities\")\n\n\n\n\n\n\n\n\n\n\n(a) A map with geometries only.\n\n\n\n\n\n\n\n\n\n(b) A map with geometries and attributes.\n\n\n\n\n\n\nFigure 3.1: Example of a quick map created with the qtm() function.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>**tmap** in a nutshell</span>"
    ]
  },
  {
    "objectID": "nutshell.html#sec-regular-maps",
    "href": "nutshell.html#sec-regular-maps",
    "title": "3  tmap in a nutshell",
    "section": "\n3.3 Regular maps",
    "text": "3.3 Regular maps\nTherefore, for most applications, we recommend using the regular mapping approach. This approach operates on many functions that start with tm_. The first element always1 is tm_shape(), which specifies the input shape object. Next, map layers, additional map elements, and overall layout options can be customized.  \nThe last example in Section 3.2 can be reproduced with the regular map approach using the following code.\n\ntm_shape(slo_cities) +\n  tm_symbols(shape = 24, size = \"population\") +\n  tm_title(\"Cities\")\n\nHere, we specify the input data (our shape object) with tm_shape(), aesthetics (also known as visual variables) of map layers with tm_symbols(), and the map title with tm_title().\nThe tmap package has a number of possible map layers, but the most prominent ones are tm_polygons(), tm_symbols(), tm_lines(), tm_raster(), and tm_text() (Chapter 6). Overall, most visual variables of map layers can be assigned in two main ways. First, they accept a fixed, constant value, for instance, shape = 24, which sets the symbols’ shapes to triangles. Second, it is also possible to provide a variable name, for example size = \"population\". This plots each point with a size based on the population attribute from the slo_cities object and automatically adds a related map legend.\nThe tm_shape() function and one or more following map layers create a group together. In other words, map layers are related only to the preceding tm_shape() call. One map can have several groups. Let’s see how many groups can be used by reading some additional datasets – the slo_elev raster with elevation data of Slovenia, the slo_borders polygon with the country borders, and the slo_railroads lines contains a railroad network for this country. \n\nlibrary(sf)\nlibrary(stars)\nslo_elev = read_stars(\"data/slovenia/slo_elev.tif\")\nslo_borders = read_sf(\"data/slovenia/slo_border.gpkg\")\nslo_railroads = read_sf(\"data/slovenia/slo_railroads.gpkg\")\n\nLook at the following example and try to guess how many groups it has, and how many layers exist for each group (Figure 3.2).\n\ntm_shape(slo_elev) +\n  tm_raster(col.scale = tm_scale(values = \"geyser\"),\n            col.legend = tm_legend(title = \"Elevation (m asl)\")) +\n  tm_shape(slo_borders) + \n  tm_borders() +\n  tm_shape(slo_railroads) +\n  tm_lines(lwd = \"track_width\", \n           lwd.legend = tm_legend(show = FALSE)) +\n  tm_shape(slo_cities) +\n  tm_symbols(shape = 24, size = \"population\",\n             size.legend = tm_legend(title = \"Population\")) +\n  tm_title(\"Slovenia\") +\n  tm_layout(bg.color = \"grey95\")\n\n\n\n\n\n\nFigure 3.2: Example of a map with four groups of map layers: an elevation layer, country borders layer, railroads layer, and cities layer.\n\n\n\n\nThe correct answer is four groups, all with just one layer. Each group is put on top of the previous one – tmap uses a layered approach. The first group represents elevation data with a continuous color scale style, a color palette called \"geyser\", and a legend title. The second group shows the borders of Slovenia with the default aesthetics, while the third group presents the railroad network (the slo_railroads object), with each line’s width based on the values from the \"track_width\" column, but with a legend hidden. The last group is similar to our previous example with fixed symbol shapes and sizes related to the \"elevation\" attribute, but also with the legend title instead of the map title. Additionally, we use the tm_title() function to add a map title and tm_layout to modify the general appearance of the map. You can also notice that we can control scales of various visual variables, such as color, size, or width, with the tm_scale_*() function and customize legends with the tm_legend() function. \nOften, maps also have additional map elements, such as graticule lines, north arrow, scale bar, or map credits (Figure 3.3). They help map readers understand the location or extent of the input data and provide some ancillary information. The tmap package offers a set of functions for additional map elements. The tm_graticules() function draws latitude and longitude graticules and adds their labels. It also uses the layered approach, and thus, the lines will be drawn either below or above the shape objects, depending on the position of this function in the code. In our example below, tm_graticules() is used after all of the map groups, and that is why the graticule lines are put on the top of the spatial data. We can also use tm_compass() to create a north arrow, tm_scalebar() to add a scale bar, and tm_credits() to add a text annotation representing credits or acknowledgments. The location of all these three elements on the map is, by default, automatically determined. It, however, can be adjusted with the position argument – see an example of its use in the tm_compass() function below. Moreover, it is possible to add any type of manual legend with tm_add_legend(). It includes simple legends below, such as the \"Railroads\" legend element, that is only represented by a single black line and a related label, but more complex custom legends with several elements are also possible. \n\nmy_map = tm_shape(slo_elev) +\n  tm_raster(col.scale = tm_scale(values = \"geyser\"),\n            col.legend = tm_legend(title = \"Elevation (m asl)\")) +\n  tm_shape(slo_borders) + \n  tm_borders() +\n  tm_shape(slo_railroads) +\n  tm_lines(lwd = \"track_width\", \n           lwd.legend = tm_legend(show = FALSE)) +\n  tm_shape(slo_cities) +\n  tm_symbols(shape = 24, size = \"population\",\n             size.legend = tm_legend(title = \"Population\")) +\n  tm_graticules() +\n  tm_compass(position = c(\"right\", \"top\")) +\n  tm_scalebar() +\n  tm_credits(\"Author, Year\") +\n  tm_add_legend(type = \"lines\", col = \"black\", labels = \"Railroads\") +\n  tm_title(\"Slovenia\") +\n  tm_layout(bg.color = \"grey95\")\n\nMaps created with tmap can be saved as an R object. This is a useful feature that allows to use one map in a few places in a code, modify existing tmap objects, or save these objects to files.\n\nmy_map\n\n\n\n\n\n\nFigure 3.3: Example of a map with four groups of map layers and additional map elements, such as graticule lines, north arrow, scale bar, and text annotation. It also has a manually added legend.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>**tmap** in a nutshell</span>"
    ]
  },
  {
    "objectID": "nutshell.html#sec-facets-section",
    "href": "nutshell.html#sec-facets-section",
    "title": "3  tmap in a nutshell",
    "section": "\n3.4 Facets",
    "text": "3.4 Facets\n The tmap package allows the creation of facet maps, also known as small multiples. In such maps, the same data is visualized in several panels, each showing a different subset of the data. The panels may represent different variables, time periods, or spatial extents.\nThe slo_regions object contains the administrative regions of Slovenia with their names, population density (gdppercap), GDP per capita (gdppercap), region group name (region_group), and other attributes. One way to visualize this data as facets is to specify selected columns as visual variables in the map layer function (e.g., tm_polygons()) (Figure 3.4).\n\nslo_regions = read_sf(\"data/slovenia/slo_regions.gpkg\")\ntm_shape(slo_regions) +\n  tm_polygons(fill = c(\"pop_dens\", \"gdppercap\", \"region_group\"))\n\n\n\n\n\n\nFigure 3.4: A facet map with three variables visualized in separate panels.\n\n\n\n\nAnother possible approach is to use the tm_facets() function. Let’s illustrate it with the slo_regions_ts object containing the same variables as slo_regions but for many years (time column). Figure 3.5 shows a facet map with the GDP per capita, specified with tm_polygons(), and visualized in separate panels for each year as defined by the tm_facets() function.\n\nslo_regions_ts = read_sf(\"data/slovenia/slo_regions_ts.gpkg\")\ntm_shape(slo_regions_ts) +\n  tm_polygons(\"gdppercap\") +\n  tm_facets(by = \"time\", ncol = 5)\n\n\n\n\n\n\nFigure 3.5: A facet map with the GDP per capita visualized in separate panels for each year.\n\n\n\n\nFacet maps can be used for vector and raster data, their extents can be adjusted, and they can be further customized with additional labels. This is a topic of the Chapter 16.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>**tmap** in a nutshell</span>"
    ]
  },
  {
    "objectID": "nutshell.html#sec-ani-section",
    "href": "nutshell.html#sec-ani-section",
    "title": "3  tmap in a nutshell",
    "section": "\n3.5 Animations",
    "text": "3.5 Animations\n Figure 3.6 shows an animated map with the GDP per capita visualized for each year. Animations in tmap are created similarly to the facet maps, but instead of using the tm_facets() function, we use the tm_animate() function. It defines the variable that will be used to create the animation, in this case, the time column from the slo_regions_ts object.\n\nslo_regions_ts = read_sf(\"data/slovenia/slo_regions_ts.gpkg\")\ntm_shape(slo_regions_ts) +\n  tm_polygons(\"gdppercap\") +\n  tm_animate(by = \"time\")\n\n\n\n\n\n\nFigure 3.6: An animated map with the GDP per capita visualized for each year.\n\n\n\n\nThis function stitches together the map layers for each value of the time variable, creating a smooth transition between them. We can customize its speed and if it should loop or not with the fps and play arguments, respectively. Animations can be used for both vector and raster data and then saved as GIF or video files using the tmap_animation() function. Chapter 17 expands on this topic and shows how to create more complex animations, such as animated maps with facets.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>**tmap** in a nutshell</span>"
    ]
  },
  {
    "objectID": "nutshell.html#sec-map-modes",
    "href": "nutshell.html#sec-map-modes",
    "title": "3  tmap in a nutshell",
    "section": "\n3.6 Map modes",
    "text": "3.6 Map modes\nEach map created with tmap can be viewed in one of two modes: \"plot\" and \"view\".  The \"plot\" mode is used by default and creates static maps similar to those shown before in this chapter. This mode supports almost all of tmap’s features, and it is recommended, for example, for scientific publications or printing.\nThe second mode, \"view\", allows the creation of interactive maps. They can be zoomed in and out or panned, allow for changing background tiles (basemaps), or click on map objects to get some additional information. This mode has, however, some constraints and limitations comparing to \"plot\", for example, the legend cannot be fully customized, and some additional map elements are not supported.\nBoth modes can be used on the same tmap code. Therefore, there is no need to create two separate maps for static and interactive use. The tmap_mode() function can be used to switch from one mode to the other2.\n\ntmap_mode(\"view\")\n#&gt; ℹ tmap mode set to \"view\".\n\nThe above line of code just changes the mode – it does not return anything except a message. Now, if we want to use this mode, we need to either write a new tmap code or provide some existing tmap object, such as my_map.\n\nmy_map\n\nOur main result is the interactive map (Figure 3.7).  It shows our spatial data using aesthetics similar to Figure 3.3 but allows us to zoom in and out or move the map. We also can select a basemap or click on any line and point to get some information.\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.7: Map from the previous figure shown using the interactive (“view”) mode.\n\n\n\nTo go back to the \"plot\" mode, we need to use the tmap_mode() function again – map not shown:\n\ntmap_mode(\"plot\")\nmy_map\n\nMore information about the interactive \"view\" mode and how to customize its outputs is in Chapter 18.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>**tmap** in a nutshell</span>"
    ]
  },
  {
    "objectID": "nutshell.html#footnotes",
    "href": "nutshell.html#footnotes",
    "title": "3  tmap in a nutshell",
    "section": "",
    "text": "Almost always…↩︎\nMap modes can be also changed globally using tmap_options() or switched using ttm().↩︎",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>**tmap** in a nutshell</span>"
    ]
  },
  {
    "objectID": "save.html",
    "href": "save.html",
    "title": "4  Save maps",
    "section": "",
    "text": "4.1 Raster graphic formats\nMaps created programmatically can serve several purposes, from exploratory, through visualizations of the processing steps, to being the final outputs of a given project. Therefore, often we want just to see our map on the screen, but sometimes we also want to save our map results to an external file. tmap objects can be directly saved to output files with tmap_save()1. The tmap_save() function allows to save our map in three groups of file formats, (a) raster graphics (Section 4.1), (b) vector graphics (Section 4.2), and (c) interactive ones (Section 4.3).\nFor the examples in this section, we will use a simple map of the Slovenia polygon with the country name superimposed (not shown), stored in the tm object.\nRaster graphics are non-spatial relatives of spatial rasters. The digital images are composed of many pixels – squares filled with specific colors. Main raster graphic file formats include PNG, JPEG, BMP, and TIFF.  One of the major parameters of the raster graphic images is DPI (Dots Per Inch, in this context, a more proper name probably should be PPI, Pixels Per Inch) – is a number of pixels per inch of the output image. For example, if the width and height of our image are 10 inches, then DPI of 300 would mean that our final image would have 3000 by 3000 pixels, and DPI of 72 would result in an image of 720 by 720 pixels. Therefore, an image with the same width and height but a larger value of DPI would occupy more space on the hard drive but also have better quality.\nSaving tmap objects to a file can be done with the tmap_save(). It usually accepts two arguments2 – the first one, tm, is our map object, and the second one, filename, is the path to the created file.\ntmap_save(tm, \"my_map.png\")\n#&gt; Map saved to my_map.png\n#&gt; Resolution: 2503 by 1762 pixels\n#&gt; Size: 8.34 by 5.87 inches (300 dpi)\nBy default, DPI is set to 300, and the image width and height is automatically adjusted based on the map aspect ratio. These parameters can be, however, changed with the dpi, width, and height arguments3.\ntmap_save(tm, \"my_map.png\", width = 1000, height = 750, dpi = 300)\n#&gt; Map saved to /home/jn/Science/geocompx/tmap/my_map.png\n#&gt; Resolution: 1000 by 750 pixels\n#&gt; Size: 3.33 by 2.5 inches (300 dpi)\nThe units of width or height depend on the value you set: they are pixels (\"px\") when the value is greater than 50, and inches (\"in\") otherwise. Units can also be changed with the units argument.\nThis function also has several additional arguments, including outer.margins, scale and asp. All of them override the arguments’ values set in tm_layout() (Chapter 12). Additionally, when set to 0, the asp argument has a side effect: it moves the map frame to the edges of the output image.\nBy default, tmap uses graphic devices4 incorporated in R. However, it is also possible to use other, external devices with the device argument.\ntmap_save(tm, \"my_map.png\", device = ragg::agg_png)\nFor example, the ragg::agg_png device is usually faster and has better support for non-standard fonts than the regular grDevices::png.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Save maps</span>"
    ]
  },
  {
    "objectID": "save.html#sec-vector-graphic-formats",
    "href": "save.html#sec-vector-graphic-formats",
    "title": "4  Save maps",
    "section": "\n4.2 Vector graphic formats",
    "text": "4.2 Vector graphic formats\nVector graphics are quite distant relatives of spatial vectors, with vector graphics consisting of sets of coordinates. Contrary to spatial vectors, however, their coordinates can be connected not only by straight lines (Section 2.2.1), but also using curves. This makes it possible to create polygons, circles, ellipses, and others. They also allow text and other objects to be stored. Common vector graphic file formats are SVG, EPS, and PDF.\nTo save a map to a vector graphic format, we still can use tmap_save() but either with a suitable file extension or by using the device argument, for example device = svglite::svglite.\n\ntmap_save(tm, \"my_map.svg\")\n#&gt; Map saved to /home/jn/Science/geocompx/tmap/my_map.svg\n#&gt; Size: 8.34 by 5.87 inches\n\nZooming in and out of vector graphics does not affect their quality. At the same time, the width, height, and scale arguments can still impact the output file. For example, a vector graphic file saved with a narrower width value will have thicker lines and larger fonts compared to the one with a larger width value. You can check this effect by saving the tm object with width = 1 and then with width = 10.\nCompared to raster graphics, vector graphics are not suitable for storing complex images or maps, and they are less supported by web browsers comparing to rasters. They, however, also have many advantages. For example, they can be zoomed in and out without any decrease in quality. Vector graphics can also be easily edited in dedicated software (e.g., Inkscape or Adobe Illustrator), which allows to change the style of map elements and move them using a computer mouse outside of the R environment. This approach can be useful, for example, when you want to quickly adjust the position of map elements (e.g., labels) or collaborate with a graphic designer. Note, however, that this process is not fully reproducible.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Save maps</span>"
    ]
  },
  {
    "objectID": "save.html#sec-interactive-format",
    "href": "save.html#sec-interactive-format",
    "title": "4  Save maps",
    "section": "\n4.3 Interactive format",
    "text": "4.3 Interactive format\ntmap map objects can not only be viewed in the interactive mode (as shown in Section 3.6) but also saved as HTML files by adding the .html extension to the output file name.\n\ntmap_save(tm, \"my_map.html\")\n#&gt; Interactive map saved to /home/jn/Science/geocompx/tmap/my_map.html\n\nThe tmap_save() function also has several additional arguments reserved for the interactive format, including selfcontained and in.iframe. The selfcontained argument with TRUE by default saves our map together with additional resources (e.g., JavaScript libraries) into one HTML file. Otherwise, additional resources will be saved in an adjacent directory. The in.iframe argument (FALSE by default) allows saving an interactive map as an iframe – when TRUE it creates two HTML files - a small HTML file with the iframe container and a large one with the actual map.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Save maps</span>"
    ]
  },
  {
    "objectID": "save.html#footnotes",
    "href": "save.html#footnotes",
    "title": "4  Save maps",
    "section": "",
    "text": "Standard R approach of saving graphic files by opening a graphic device, e.g., png(), plotting the data, and then closing the device with dev.off() also works.↩︎\nIn fact, one argument is enough – if you just provide a tmap object, then it will be saved to a tmap01 file with some default format.↩︎\nYou can even specify just one of width or height, and the value of the second one will be calculated using the formula asp = width / height.↩︎\nShort discussion about graphic devices can be found in section Section 12.3.2.↩︎",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Save maps</span>"
    ]
  },
  {
    "objectID": "tm-shape.html",
    "href": "tm-shape.html",
    "title": "5  Specifying spatial data",
    "section": "",
    "text": "5.1 Shapes and layers\nAt least two aspects need to be specified in order to plot spatial data: the spatial data object itself and the plotting method(s). We will cover the former in this chapter. The latter will be discussed in the next chapters.\nAs described in Chapter 2, shape objects can be vector or raster data. We recommend sf objects for vector data and stars objects for raster data1.\nlibrary(tmap)\nlibrary(sf)\nlibrary(stars)\nworldelevation = read_stars(\"data/worldelevation.tif\")\nworldvector = read_sf(\"data/worldvector.gpkg\")\nworldcities = read_sf(\"data/worldcities.gpkg\")\nIn tmap, a shape object needs to be defined with the function tm_shape(). When multiple shape objects are used, each has to be defined in a separate tm_shape() call. This is illustrated in the following example (Figure 5.1).\ntm_shape(worldelevation) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = \"geyser\", midpoint = NA)) +\n  tm_shape(worldvector) +\n  tm_borders() +\n  tm_shape(worldcities) +\n  tm_dots() +\n  tm_text(\"name\")\n\n\n\n\n\n\nFigure 5.1: A map representing three shapes (worldelevation, worldvector, and worldcities) using four layers.\nIn this example, we use three shapes: worldelevation which is a stars object containing an attribute called \"worldelevation.tif\", worldvector which is an sf object with country borders, and worldcities – an sf object that contains metropolitan areas of at least 20 million inhabitants.\nEach tm_shape() function call is succeeded by one or more layer functions. In the above example, these are tm_raster(), tm_borders(), tm_dots() and tm_text(). We will describe layer functions in detail in the next chapter. For this chapter, it is sufficient to know that each layer function call defines how the spatial data specified with tm_shape() is plotted.\nShape objects can be used to plot multiple layers. In the example, shape worldcities is used for two layers, tm_dots() and tm_text().",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Specifying spatial data</span>"
    ]
  },
  {
    "objectID": "tm-shape.html#sec-shapes-hierarchy",
    "href": "tm-shape.html#sec-shapes-hierarchy",
    "title": "5  Specifying spatial data",
    "section": "\n5.2 Shapes hierarchy",
    "text": "5.2 Shapes hierarchy\nThe order of the tm_shape() functions’ calls is crucial. The first tm_shape(), known as the main shape, is not only shown below the following shapes, but also sets the projection and extent of the whole map. In Figure 5.1, the worldelevation object was used as the first shape, and thus the whole map has the projection and extent of this object.\nHowever, we can quickly change the main shape with the is.main argument. In the following example, we set the worldcities object as the main shape, which limits the output map to the point locations in worldcities (Figure 5.2)2.\n\ntm_shape(worldelevation) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = \"geyser\", midpoint = NA)) +\n  tm_shape(worldvector) +\n  tm_borders() +\n  tm_shape(worldcities, is.main = TRUE) +\n  tm_dots() +\n  tm_text(\"name\")\n\n\n\n\n\n\nFigure 5.2: A map representing three shapes (worldelevation, worldvector, and worldcities) using four layers and zoomed into the locations in the worldcities object.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Specifying spatial data</span>"
    ]
  },
  {
    "objectID": "tm-shape.html#sec-map-extent",
    "href": "tm-shape.html#sec-map-extent",
    "title": "5  Specifying spatial data",
    "section": "\n5.3 Map extent",
    "text": "5.3 Map extent\nAnother important aspect of mapping, besides projection, is its extent – a portion of the area shown in a map.  This is not an issue when the extent of our spatial data is the same as we want to show on a map. However, what should we do when the spatial data contains a larger region than we want to present?\nAgain, we could take two routes. The first one is to preprocess our data before mapping - this can be done with vector clipping (e.g., st_intersection()) and raster cropping (e.g., st_crop()). We would recommend this approach if you plan to work on the smaller data in the other parts of the project. The second route is to specify the map extent in tmap.\ntmap allows specifying map extent using three approaches. The first one is to specify minimum and maximum coordinates in the x and y directions that we want to represent. This can be done with a numeric vector of four values in the order of minimum x, minimum y, maximum x, and maximum y, where all of the coordinates need to be specified in the input data units3 In the following example, we limit our map extent to the rectangular area between x from -15 to 45 and y from 35 to 65 (Figure 5.3).\n\ntm_shape(worldelevation, bbox = c(-15, 35, 45, 65)) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = \"geyser\", midpoint = NA))\n\n\n\n\n\n\nFigure 5.3: Global elevation data limited to the extent of the specified minimum and maximum coordinates.\n\n\n\n\nThe second approach allows for the map to be set to an extent based on a search query. In the code below, we limit the map extent to the area of \"Europe\" (Figure 5.4). This approach uses the OpenStreetMap tool called Nominatim to automatically generate minimum and maximum coordinates in the x and y directions based on the provided query. \n\ntm_shape(worldelevation, bbox = \"Europe\") +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = \"geyser\", midpoint = NA))\n\n\n\n\n\n\nFigure 5.4: Global elevation data limited to the extent specified with the ‘Europe’ query.\n\n\n\n\nIn the last approach, the map extent is based on another existing spatial object. Figure 5.5 shows the elevation raster data (worldelevation) limited to the edge coordinates from worldcities.\n\ntm_shape(worldelevation, bbox = worldcities) +\n  tm_raster(\"worldelevation.tif\", \n            col.scale = tm_scale(values = \"geyser\", midpoint = NA))\n\n\n\n\n\n\nFigure 5.5: Global elevation data limited to the extent of the other spatial object.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Specifying spatial data</span>"
    ]
  },
  {
    "objectID": "tm-shape.html#sec-map-projection-intro",
    "href": "tm-shape.html#sec-map-projection-intro",
    "title": "5  Specifying spatial data",
    "section": "\n5.4 Map projection",
    "text": "5.4 Map projection\n\nAs we mentioned in the previous section, created maps use the projection from the main shape. However, we often want to create a map with a different projection, for example, to preserve a specific map property. We can do this in three ways. The first way to use a different projection on a map is to reproject the main data before plotting. The second way is to specify the map projection using the crs argument of tm_shape(). This argument expects either some crs object or a CRS code. The third way is to use a tm_crs() function.\nThe next code chunks shows all of the three ways, in which we transform the CRS of the worldvector object to \"EPSG:8857\". This represents a projection called Equal Earth (Šavrič, Patterson, and Jenny 2019). The Equal Earth projection is an equal-area pseudocylindrical projection for world maps similar to the non-equal-area Robinson projection (Figure 13.6).\n\n#1\nworldvector8857 = st_transform(worldvector, crs = \"EPSG:8857\")\ntm_shape(worldvector8857) +\n  tm_polygons()\n#2\ntm_shape(worldvector, crs = \"EPSG:8857\") +\n  tm_polygons() \n#3\ntm_shape(worldvector) +\n  tm_polygons() +\n  tm_crs(\"EPSG:8857\")\n\nThe first way requires understanding various R packages, as different spatial objects have different functions for changing the projection. The second way is the most straightforward, but it is important to remember that the crs argument can only be set in the main layer (Section 5.2). The third way is the most flexible, as it allows changing the projection for the whole map. Additionally, the tm_crs() function can automatically determine the projection based on the expected property of the map, e.g., equal area (\"area\"), equidistant (\"distance\"), or conformal (\"shape\"). For example, tm_crs(\"auto\") will choose the projection that best preserves the area of the map (Lambert Azimuthal Equal Area), while tm_crs(\"auto\", property = \"shape\") will choose the projection that best preserves the shape of the map (Stereographic).\nChapter 13 expands on the topic of map projections. It starts by explaining the basic concepts and then show how to apply them in tmap.\n\n\n\n\nŠavrič, Bojan, Tom Patterson, and Bernhard Jenny. 2019. “The Equal Earth Map Projection.” International Journal of Geographical Information Science 33 (3): 454–65. https://doi.org/10/cs8v.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Specifying spatial data</span>"
    ]
  },
  {
    "objectID": "tm-shape.html#footnotes",
    "href": "tm-shape.html#footnotes",
    "title": "5  Specifying spatial data",
    "section": "",
    "text": "However, tmap also accepts other spatial objects, e.g., of sp, raster, and terra classes.↩︎\nWe will show how to adjust margins and text locations later in the book↩︎\nThis can also be done with the object of class st_bbox or a 2 by 2 matrix.↩︎",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Specifying spatial data</span>"
    ]
  },
  {
    "objectID": "layers.html",
    "href": "layers.html",
    "title": "6  Layers",
    "section": "",
    "text": "6.1 Polygons\nMap layers are the main building blocks of a map. They specify how the specific data should be visualized – for example, as polygons, symbols, lines, text labels, or raster. There is also an interplay between the data and the map layers: raster data can be plotted with the tm_raster() or tm_rgb() functions, while point data can be visualized with tm_symbols(), tm_dots(), tm_bubbles(), tm_markers(), or tm_squares(). Moreover, some data types can be simplified and shown with a different geometry, such as polygons that are usually visualized with tm_polygons() but can also converted into centroids and plotted with tm_symbols().\nEach dataset may have one or more layers, and each layer can be visualized in different ways. For example, a dataset with polygons can be visualized using tm_polygons() to display the polygon areas, and then the names of the polygons can be added with tm_text().\nTable 14.1 shows the available map layers in tmap. They are divided into two groups: basic functions and derived functions. The basic functions are the main functions for visualizing data, are useful for most cases, and are highly customizable. The derived functions are built on top of the basic functions but with different default values aimed at specific use cases.\nIn this chapter, we focus on what map layers are available in tmap and how they differ. Chapter 7, on the other hand, is all about how to present information given in variables using colors, sizes, and shapes.\nlibrary(tmap)\nlibrary(sf)\nslo_borders = read_sf(\"data/slovenia/slo_border.gpkg\")\nThe main function of visualizing polygons is tm_polygons(). By default, it plots areas of polygons in light gray (gray85) and polygons borders in slightly dark gray (gray25).\ntm_shape(slo_borders) +\n  tm_polygons()\nBoth, colors of areas (polygons’ fillings) and colors of borders can be modified using the fill and col arguments (Figure 6.1 (a)).\ntm_shape(slo_borders) +\n  tm_polygons(fill = \"lightblue\", col = \"black\", lwd = 0.5, lty = \"dashed\")\nIn fact, tm_polygons() is a combination of two separate functions: tm_fill() and tm_borders(). The tm_fill() function fills polygons with a fixed color or a color palette representing a selected variable (Figure 6.1 (b)).\ntm_shape(slo_borders) +\n  tm_fill(fill = \"lightblue\")\nThe tm_borders() function draws the borders of the polygons only (Figure 6.1 (c)). It allows you to change the colors of borders, their widths, or the lines type.\ntm_shape(slo_borders) +\n  tm_borders(col = \"black\", lwd = 0.5, lty = \"dashed\")\n(a) tm_polygons()\n\n\n\n\n\n\n\n\n\n(b) tm_fill()\n\n\n\n\n\n\n\n\n\n(c) tm_borders()\n\n\n\n\n\n\nFigure 6.1: Example of a map created using:\nMore information on colors and how they can be applied and modified is explained in detail in Section 7.3.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Layers</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-symbols",
    "href": "layers.html#sec-symbols",
    "title": "6  Layers",
    "section": "\n6.2 Symbols",
    "text": "6.2 Symbols\n\nslo_cities = read_sf(\"data/slovenia/slo_cities.gpkg\")\n\nSymbols are a versatile type of layer. They are usually used to represent point data but can also be used for lines and polygons. In the latter cases, they are located in the centroid coordinates of each feature. Their flexibility is also related to the ways symbols can be visualized – it is possible to show values of a given variable by colors of symbols, their sizes, or shapes (more about that is explained in Chapter 7).\nThe tm_symbols() is the main function in tmap, allowing to use and modify symbol elements (Figure 6.2). By default, this function draws a gray circle symbol with a black border for each element of an input feature.\n\n\n\n\n\n\n\nFigure 6.2: A map showing the default tmap symbols.\n\n\n\n\nIn the above example, each symbol is related to one feature (row) in the slo_cities object. However, in a case when we provide multi-element features (such as MULTIPOINT; see Section 2.2.1), each multi-element object is first split into a number of single-element features and then plotted.\nThe tm_symbols() is a very flexible function with a large number of arguments. While this allows adjusting its results to almost any need, it also makes this function complicated. Therefore, four additional layers are implemented in tmap: tm_squares(), tm_bubbles(), tm_dots(), tm_markers(). All of them use tm_symbols(), but with different default values.\ntm_squares() uses square symbols (shape = 22) instead of circles (shapes = 21) (Figure 6.3 (a)). \n\ntm_shape(slo_cities) +\n  tm_squares()\n\n\nNext, tm_bubbles() uses circles with a larger size value than the default one (Figure 6.3 (b)). \n\ntm_shape(slo_cities) +\n  tm_bubbles()\n\nThe main role of tm_dots() is to present many locations at the same time. To do this, this layer has a small size value (0.02) at the default (Figure 6.3 (c)).\n\ntm_shape(slo_cities) +\n  tm_dots()\n\nThe last additional layer is tm_markers(), which uses a marker icon by default (Figure 6.3 (d)).\n\ntm_shape(slo_cities) +\n  tm_markers()\n\n\n\n\n\n\n\n\n\n\n\n(a) tm_squares()\n\n\n\n\n\n\n\n\n\n(b) tm_bubbles()\n\n\n\n\n\n\n\n\n\n\n\n(c) tm_dots()\n\n\n\n\n\n\n\n\n\n(d) tm_markers()\n\n\n\n\n\n\nFigure 6.3: Maps showing default visualizations using various types of symbols.\n\n\n\nIn Section 7.4 and Section 7.5, we learn how to modify the size and shape of symbols, including creating custom shapes.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Layers</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-lines",
    "href": "layers.html#sec-lines",
    "title": "6  Layers",
    "section": "\n6.3 Lines",
    "text": "6.3 Lines\n\nslo_railroads = read_sf(\"data/slovenia/slo_railroads.gpkg\")\n\nThe tm_lines() function allows the visualization of different types of line data (Figure 6.4).\n\ntm_shape(slo_railroads) + \n  tm_lines()\n\n\n\n\n\n\nFigure 6.4: Example of a map created with tm_lines().\n\n\n\n\nLines can be presented using different colors, widths, or types (Chapter 7). This allows to show a hierarchy (for example, increased line widths for higher capacity roads) or distinguish between types of objects (for example, blue rivers comparing to gray roads).",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Layers</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-text",
    "href": "layers.html#sec-text",
    "title": "6  Layers",
    "section": "\n6.4 Text",
    "text": "6.4 Text\nText labels are often an integral part of many maps. They can serve several functions, from naming features, indicating relations between them, or representing a given variable’s values. The primary function for creating text labels is tm_text(), which adds a label to each spatial feature (Figure 6.5 (a)).\n\ntm = tm_shape(slo_borders) +\n  tm_polygons() + \n  tm_shape(slo_cities) +\n  tm_dots()\ntm +\n  tm_text(text = \"name\")\n\nTwo additional functions for adding text labels are tm_labels() and tm_labels_highlighted(). They are similar to tm_text(), but have different defaults. The tm_labels() function is used to add text labels to the map, but also tries to automatically adjust the position of the labels to avoid overlapping with other features (Figure 6.5 (b)).\n\ntm +\n  tm_labels(text = \"name\")\n\nThe tm_labels_highlighted() additionally adds a background color to the labels, which makes them more visible (Figure 6.5 (c)). \n\ntm +\n  tm_labels_highlighted(text = \"name\")\n\n\n\n\n\n\n\n\n\n\n(a) tm_text()\n\n\n\n\n\n\n\n\n\n(b) tm_labels()\n\n\n\n\n\n\n\n\n\n(c) tm_labels_highlighted()\n\n\n\n\n\n\nFigure 6.5: Maps with text labels.\n\n\nIn the above examples, the text argument specifies the name of a variable that will be used for text labels. We can further adjust colors (col; Section 7.3), sizes (size; Section 7.4), font faces (fontface; Section 12.3), and background colors (bgcol) of labels by providing either a single value or the name of a data variable.\nThe tm_text(), tm_labels(), and tm_labels_highlighted() functions have many arguments that allow us to adjust the appearance of text labels. It includes arguments related to the x and y offset of the text labels (xmod and ymod), and the rotation angle (angle).  Figure 6.6 (a) shows an example of a map with text labels moved a bit to the right and down, and rotated by 12 degrees.\n\ntm +\n  tm_text(text = \"name\", xmod = 1, ymod = -0.5, angle = 12)\n\nText labels can be further modified with the opt_tm_text() function provided to the options argument.  It includes a set of arguments that allow for the adjustment of the text labels’ appearance, such as shadow, just, and remove_overlap (Figure 6.6 (b)).\n\ntm +\n  tm_text(text = \"name\", xmod = 1, ymod = -0.5, angle = 12,\n          options = opt_tm_text(shadow = TRUE,\n                                just = \"left\",\n                                remove_overlap = TRUE))\n\nTo automatically adjust the position of text labels to avoid overlapping with other features, we can use the point.label argument in the opt_tm_text() function. When set to TRUE, it will use an algorithm to find the best position for each label, which can be useful when there are many overlapping features or when the labels are too close to each other.\n\ntm +\n  tm_text(text = \"name\", \n          options = opt_tm_text(point.label = TRUE))\n\n\n\n\n\n\n\n\n\n\n(a) with x and y offsets and rotation angle\n\n\n\n\n\n\n\n\n\n(b) with shadow and left justification\n\n\n\n\n\n\n\n\n\n(c) with point.label = TRUE\n\n\n\n\n\n\nFigure 6.6: Example of a map created with tm_text() with customized options\n\n\n\n\nText labels can be added to spatial (multi-)points, (multi-)lines, and (multi-)polygons, and each case is quite different. The simplest case is for POINT data, for which each text label will be located precisely in the coordinates of the given points (Figure 6.5). However, how to add text labels to multipoints, lines, multilines, polygons, or multipolygons? Should each label correspond to one spatial feature, or should every sub-feature have its own label? Where should the labels be placed for lines or polygons – in the center of a line and the centroid of a polygon, or somewhat different? The above decisions can be made with the options argument of the tm_text() function. By default, text labels are placed in the centroid of each feature; however, we can change this behavior with the point_per argument. The possible options are \"feature\" (default), \"segment\", and \"largest\". The \"segment\" option labels each subfeature (e.g, each point in a multipoint, each segment in a multilines, and each polygon in a multipolygon) and the \"largest\" option labels only the largest subfeature (e.g., the largest segment in a multilines or the largest polygon in a multipolygon).\nText labels are also often presented together with lines (Section 6.3). One example is an isopleth—a line drawn on a map through all points with the same value of a given variable, such as atmospheric pressure or elevation. Isopleths can be created with the tm_iso() function. This function combines tm_lines() and tm_text(), where text labels are placed on the isopleths along the lines. In the example below, we create contour lines (isopleths) from the elevation raster data of Slovenia, and then we plot them on the map with text labels (Figure 6.7).\n\nlibrary(terra)\nslo_elev = rast(\"data/slovenia/slo_elev.tif\")\nslo_contours = as.contour(slo_elev, nlevels = 4)\ntm_shape(slo_borders) +\n  tm_borders() + \n  tm_shape(slo_contours) +\n  tm_iso()\n\n\n\n\n\n\nFigure 6.7: Example of a map created with tm_iso() showing contour lines with text labels.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Layers</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-raster-layer",
    "href": "layers.html#sec-raster-layer",
    "title": "6  Layers",
    "section": "\n6.5 Raster",
    "text": "6.5 Raster\n\nlibrary(stars)\nslo_elev = read_stars(\"data/slovenia/slo_elev.tif\")\nslo_gm = read_stars(\"data/slovenia/slo_gm.tif\")\n\nVisualization of raster data depends on the raster type (continuous or categorical), its resolution, and the number of layers. Figure 19.1 shows two simple examples of continuous and categorical raster visualizations created with tm_raster(). This function attempts to recognize the type of a given raster – when the input raster is continuous then the pretty style is used (Figure 6.8 (a)).\n\ntm_shape(slo_elev) +\n  tm_raster()\n\nHowever, the continuous scale (tm_scale_continuous()) may better represent phenomena that progressively vary in space – as you can see in Section 8.6.\nOn the other hand, when the given raster is categorical, then tm_raster() uses tm_scale_categorical() automatically (Figure 6.8 (b)).\n\ntm_shape(slo_gm) +\n  tm_raster()\n\n\n\n\n\n\n\n\n\n\n\n(a) Continuous raster map\n\n\n\n\n\n\n\n\n\n(b) Categorical raster map\n\n\n\n\n\n\nFigure 6.8: Examples of raster maps\n\n\n\nWe can also adjust the legend title, used colors, and many more, in a similar fashion as in the previously mentioned layers.\nThe above examples used a raster with one layer only. However, rasters can have many layers, either represented by layers from the terra package or dimensions and attributes from the stars package. By default, tmap shows all of the layers, where each raster has its own legend.\n\nraster2 = c(slo_elev, slo_gm)\ntm_shape(raster2) +\n  tm_raster()\n\nWe can modify their arrangement with tm_facets() (Figure 6.9).\n\ntm_shape(raster2) +\n  tm_raster() +\n  tm_facets(ncol = 1) +\n  tm_layout(panel.labels = c(\"Elevation\", \"Geomorphons\"))\n\n\n\n\n\n\nFigure 6.9: A map created from a multilayered raster.\n\n\n\n\nIf you want to learn more – we focus on how to modify map layout in Chapter 12 and how to specify and modify facets (also known as small multiples) in Chapter 16.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Layers</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-tile-layer",
    "href": "layers.html#sec-tile-layer",
    "title": "6  Layers",
    "section": "\n6.6 Tile",
    "text": "6.6 Tile\n\n\n\nTile layers can be used for two purposes: either as a basemap or an overlay layer. By default, three basemaps are used in the interactive mode (tmap_mode(\"view\")): \"Esri.WorldGrayCanvas\", \"OpenStreetMap\", and \"Esri.WorldTopoMap\". However, we can change the basemaps with a vector with the names of the tile layers’ providers (Figure 6.10).\n\ntmap_mode(\"view\")\ntm_basemap(c(StreetMap = \"OpenStreetMap\", TopoMap = \"OpenTopoMap\")) +\n  tm_shape(slo_cities, is.main = TRUE) + \n  tm_dots(col = \"red\", group = \"slo_cities\")\n\n\n\n\n\n\n\n\nFigure 6.10: OpenStreetMap tile layer used as a base map with the red dots representing cities in Slovenia.\n\n\n\nIn the above code, we made two basemaps available: \"OpenStreetMap\" and \"OpenTopoMap\", and for the map legend purpose, we renamed them as StreetMap and TopoMap. A complete list of available basemaps is in the leaflet::providers object and on the https://leaflet-extras.github.io/leaflet-providers/preview/ website1.      The tm_basemap(NULL) function allows to disable basemaps entirely.\nThe tm_tiles() function, on the other hand, draws the tile layer on the top (as an overlay layer) of the previous tm_ layer. In the next example, we put the vector \"CartoDB.PositronOnlyLabels\" tiles on top of the previously set basemaps, but below the dots layer (Figure 6.11).\n\ntm_basemap(c(StreetMap = \"OpenStreetMap\", TopoMap = \"OpenTopoMap\")) +\n  tm_tiles(c(CartoDB = \"CartoDB.PositronOnlyLabels\")) +\n  tm_shape(slo_cities, is.main = TRUE) + \n  tm_dots(col = \"red\", group = \"slo_cities\")\n\n\n\n\n\n\n\n\nFigure 6.11: OpenStreetMap tile layer used as a base map with dashed lines representing island coastline and the red dots representing slo_cities on Easter Island.\n\n\n\nTile layers are usually created to be used interactively. We can see it, for example, by the number of details varying depending on the zoom level we set. That being said, many people find them useful also for static maps, and tmap allows us to use them in this way. It uses the maptiles package to download the tiles and then plot them as a raster layer.\nA complete list of available providers and some information about zoom levels are in the help file of the ?maptiles::get_tiles() function. Different map tiles providers offer unique map styles, while zoom levels relate to different levels of detail – the larger level, the more details we will get. When using map tiles, we should also consider adding their attribution to the map. Attribution for each provider can be obtained using the maptiles::get_credit() function by specifying the provider name, for example, get_credit(\"CartoDB.VoyagerNoLabels\").\nThe code below plots the \"CartoDB.VoyagerNoLabels\" tiles in the background, adds the island outline in light blue color, and puts attribution text in the bottom right corner of the map (Figure 6.12)).\n\ntmap_mode(\"plot\")\n#&gt; ℹ tmap mode set to \"plot\".\ntm_basemap(\"CartoDB.VoyagerNoLabels\") + \n  tm_shape(slo_borders) +\n  tm_borders(lwd = 5, col = \"lightblue\") +\n  tm_credits(maptiles::get_credit(\"CartoDB.VoyagerNoLabels\"),\n             bg.color = \"white\")\n\n\n\n\n\n\nFigure 6.12: Example of a static map using a downloaded \"CartoDB.VoyagerNoLabels\" tile layer.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Layers</span>"
    ]
  },
  {
    "objectID": "layers.html#footnotes",
    "href": "layers.html#footnotes",
    "title": "6  Layers",
    "section": "",
    "text": "Additional details can be found in the leaflet::providers.details object↩︎",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Layers</span>"
    ]
  },
  {
    "objectID": "visual-variables.html",
    "href": "visual-variables.html",
    "title": "7  Visual variables",
    "section": "",
    "text": "7.1 Constant visual values\nVisual variables are methods to translate information given in variables into many types of visualizations, including maps. Basic visual variables are color, size, and shape1. All of them can influence our perception and understanding of the presented information; therefore, it is worth understanding when and how they can be used.\nThe use of visual variables on maps depends on two main things: (a) type of the presented variable, and (b) type of the map layer (Section 7.1;Section 7.2).\nFigure 7.1 shows examples of different visual variables. Color is the most universal visual variable (Section 7.3). It can represent both qualitative (categorical) and quantitative (numerical) variables, and also we can color symbols, lines, or polygon fillings. Sizes, on the other hand, should focus on quantitative variables. Small symbols could represent low values of a given variable, and the higher the value, the larger the symbol. Quantitative values of line data can be shown with the widths of the lines (Section 7.4). The use of shapes usually should be limited to qualitative variables, and different shapes can represent different categories of points (Section 7.5). Similarly, qualitative variables in lines can be presented by different line types. Values of polygons usually cannot be represented by either shapes or sizes, as these two features are connected to the geometries of the objects.  Finally, there are some cases in which we can use several visual variables at the same time (Section 7.6).\nBefore we start using visual variables, it is worth reminding that we can set constant values for visual variables: fill, color, size, and shape for all objects on the map. For example, with tm_polygons() we can fill all polygons with the same color, and set borders to the same color, width, and type (Figure 7.2).\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"lightblue\", \n              col = \"black\",\n              lwd = 0.5,\n              lty = \"dashed\")\n\n\n\n\n\n\nFigure 7.2: Example of a map with all polygons filled with the same color.\nAdditionally, for polygons, we can set the fill color in such a way that adjacent polygons do not get the same color (Figure 7.3). This is done by setting the fill argument to \"MAP_COLORS\".\nFigure 7.3: Example of a map with adjacent polygons having different colors.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Visual variables</span>"
    ]
  },
  {
    "objectID": "visual-variables.html#sec-auto-scales",
    "href": "visual-variables.html#sec-auto-scales",
    "title": "7  Visual variables",
    "section": "\n7.2 Automatic scales",
    "text": "7.2 Automatic scales\nOn the other hand, if we provide a name of the column (variable) we want to visualize, tmap will automatically set the visual variables. The tmap package has many defaults that automatically specify colors, sizes, and shapes used on the maps. Thus, for example, when we provide a character variable’s name to the fill argument, then the color scale for a categorical variable is set, and when we provide a numeric variable’s name to the size argument, then the size scale for a continuous variable is used. However, tmap also allows us to change them with a few additional functions, including tm_scale() and tm_legend(). In this and the following sections, we will show how to use the tm_scale() function to modify the appearance of the visual variables. \nThe most basic use of the tm_scale() function is to modify the appearance of the map, such as changing the color palette (col.scale and fill.scale), sizes (size.scale), or shapes (shape.scale). This is done with the values argument, which can be one of many things, depending on the visual variable. For example, for colors, it can be a vector of colors, a palette function, or a name of a build-in palette; for sizes, it can be a numerical variable; and for shapes, it can be a custom icon or a numerical variable (Figure 7.4).\ntm_shape(slo_cities) +\n  tm_symbols(fill = \"population\",\n             fill.scale = tm_scale(values = \"greens\"))\ntm_shape(slo_cities) +\n  tm_symbols(col = \"population\",\n             col.scale = tm_scale(values = c(\"red\", \"blue\")))\ntm_shape(slo_cities) +\n  tm_symbols(size = \"population\",\n             size.scale = tm_scale(values = 1:5))\ntm_shape(slo_cities) + \n  tm_symbols(shape = \"population\", \n             shape.scale = tm_scale(values = 1:6))\n\n\n\n\n\n\n\n\n\n(a) A name of a build-in color palette\n\n\n\n\n\n\n\n\n\n(b) A vector of colors\n\n\n\n\n\n\n\n\n\n\n\n(c) A numerical variable for sizes\n\n\n\n\n\n\n\n\n\n(d) A numerical variable for shapes\n\n\n\n\n\n\nFigure 7.4: Examples of various ways of specifying values for visual variables\n\n\nThe following sections Section 7.3, Section 7.4, and Section 7.5 explain the basic visual variables. Next, they show how to set colors, sizes, and shapes for different types of spatial objects.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Visual variables</span>"
    ]
  },
  {
    "objectID": "visual-variables.html#sec-colors",
    "href": "visual-variables.html#sec-colors",
    "title": "7  Visual variables",
    "section": "\n7.3 Colors",
    "text": "7.3 Colors\n Colors, along with sizes and shapes, are the most often used to express values of attributes or their properties. Proper use of colors draws the attention of viewers and has a positive impact on the clarity of the presented information. On the other hand, poor decisions about colors can lead to misinterpretation of the map.\n \n\n\n\n Colors in R are created based either on the color name or its hexadecimal form. R understands 657 built-in color names, such as \"red\", \"lightblue\" or \"gray90\", that are available using the colors() function.   Hexadecimal form, on the other hand, can represent 16,777,216 unique colors. It consists of six-digits prefixed by the # (hash) symbol, where red, green, and blue values are each represented by two characters. In hexadecimal form, 00 is interpreted as 0.0 which means a lack of a particular color and FF means 1.0 and shows that the given color has maximal intensity. For example, #000000 represents black color, #FFFFFF white color, and #00FF00 green color. \nUsing a single color we are able to draw points, lines, polygon borders, or their areas. In that scenario, all of the elements will have the same color. However, often, we want to represent different values in our data using different colors. This is a role for color palettes. A color palette is a set of colors used to distinguish the values of variables on maps.\n Color palettes in R are usually stored as a vector of either color names or hexadecimal representations. For example, c(\"red\", \"green\", \"blue\") or c(\"#66C2A5\", \"#FC8D62\", \"#8DA0CB\"). It allows every one of us to create our own color palettes. However, the decision on how to decide which colors to use is not straightforward, and usually requires thinking about several aspects.\n Firstly, what kind of variable we want to show?  Is it a categorical variable where each value represents a group or a numerical variable in which values have order?  The variable type impacts how it should be presented on the map. For categorical variables, each color usually should receive the same perceptual weight, which is done by using colors with the same brightness, but different hue. On the other hand, for numerical variables, we should easily understand which colors represent lower and which represent higher values. This is done by manipulating colorfulness and brightness. For example, low values could be presented by a blue color with low colorfulness and high brightness, and with growing values, colorfulness increases, and brightness decreases.\n The next consideration is related to how people  perceive some colors. Usually, we want them to be able to preliminary understand which values the colors represent without looking at the legend – colors should be intuitive. For example, in the case of categorical variables representing land use, we usually want to use some type of blue color for rivers, green for trees, and white for ice. This idea also extends to numerical variables, where we should think about the association between colors and cultural values. The blue color is usually connected to cold temperature, while the red color is hot or can represent danger or something not good. However, we need to be aware that the connection between colors and cultural values varied between cultures. \n Another thing to consider is to use a color palette that is accessible for people with color vision deficiencies (color blindness).  There are several types of color blindness, with red-green color blindness (deuteranomaly) being the most common. It is estimated that up to about 8% of the male population and about 0.5% of the female population in some regions of the world is color blind (Birch 2012; Sharpe et al. 1999). \n\n\nThe relation between the selected color palette and other map elements or the map background should also be taken into consideration. For example, using a bright or dark background color on a map has an impact on how people will perceive different color palettes.   \n\n\n\n\n Generally, color palettes can be divided into three main types (Figure 7.5):\n\n\nCategorical (also known as Qualitative): used for presenting categorical information, such as categories or groups. Every color in this type of palette should receive the same perceptual weight, and the order of colors is meaningless. Categorical color palettes are usually limited to a dozen or so different colors, as our eyes have problems with distinguishing a large number of different hues. Their use includes, for example, regions of the world or land cover categories.\n\nSequential: used for presenting continuous variables, in which order matters. Colors in this palette type changes from low to high (or vice versa), which is usually underlined by luminance differences (light-dark contrasts). Sequential palettes can be found in maps of GDP, population density, elevation, and many others.\n\nDiverging: used for presenting continuous variables, but where colors diverge from a central neutral value to two extremes. Therefore, in a sense, they consist of two sequential palettes that meet in the midpoint value. Examples of diverging palettes include maps where a certain temperature or median value of household income is use as the midpoint. It can also be used on maps to represent differences or change as well.\n\n\n\n\n\n\n\n\nFigure 7.5: Examples of three main types of color palettes: categorical, sequential, and diverging\n\n\n\n\n Gladly, a lot of work has been put on creating color palettes that are grounded in the research of perception and design. Currently, several dozens of R packages contain hundreds of color palettes. The most popular among them are RColorBrewer (Neuwirth 2014) and viridis (Garnier 2018). RColorBrewer builds upon a set of perceptually ordered color palettes (Harrower and Brewer 2003) and the associated website at https://colorbrewer2.org. The website not only presents all of the available color palettes, but also allow to filter them based on their properties, such as being colorblind safe or print-friendly. The viridis package has five color palettes that are perceptually uniform and suitable for people with color blindness. Four palettes in this package (“viridis”, “magma”, “plasma”, and “inferno”) are derived from the work on the color palettes for the matplotlib Python library. The last one, “cividis”, is based on the work of Nuñez, Anderton, and Renslow (2018).\n\nRColorBrewer::brewer.pal(7, \"RdBu\")\n#&gt; [1] \"#B2182B\" \"#EF8A62\" \"#FDDBC7\" \"#F7F7F7\" \"#D1E5F0\" \"#67A9CF\" \"#2166AC\"\nviridis::viridis(7)\n#&gt; [1] \"#440154FF\" \"#443A83FF\" \"#31688EFF\" \"#21908CFF\" \"#35B779FF\" \"#8FD744FF\"\n#&gt; [7] \"#FDE725FF\"\n\n In the last few years, the grDevices package that is an internal part of R, has received several improvements in color palette handling.2 It includes the creation of hcl.colors() and palette.colors(). The hcl.colors() function incorporates color palettes from several R packages, including RColorBrewer, viridis, rcartocolor (CARTO 2019; Nowosad 2018), and scico (Crameri 2018; Pedersen and Crameri 2020). You can get the list of available palette names for hcl.colors() using the hcl.pals() function and visualize all of the palettes with colorspace::hcl_palettes(plot = TRUE). The palette.colors() function adds several palettes for categorical data. It includes \"Okabe-Ito\" suited for color vision deficiencies or \"Polychrome 36\" that has 36 unique colors (Coombes et al. 2019). You can find the available names of the palettes for this function using palette.pals()\n\ngrDevices::hcl.colors(7, \"Oslo\")\n#&gt; [1] \"#FCFCFC\" \"#C2CEE8\" \"#86A2D3\" \"#3C79C0\" \"#275182\" \"#132B48\" \"#040404\"\ngrDevices::palette.colors(7, \"Okabe-Ito\")\n#&gt; [1] \"#000000\" \"#E69F00\" \"#56B4E9\" \"#009E73\" \"#F0E442\" \"#0072B2\" \"#D55E00\"\n\nThe cols4all package  is a set of tools for selecting color palettes; it also includes all of the groups of color palettes mentioned above and more. Its main function is cols4all::c4a_gui() that starts an interactive application allowing to see and examine hundreds of color palettes. Each color palette shown cols4all::c4a_gui() can be used in tmap.\n One of the most widely used color palettes is “rainbow” (the rainbow() function in R). It was inspired by colors of a rainbow – a set of seven colors going from red to violet. However, this palette has a number of disadvantages, including irregular changes in brightness affecting its interpretation or being unsuitable for people with color vision deficiencies (Borland and Taylor Ii 2007; Stauffer et al. 2015; Quinan et al. 2019). Depending on a given situation, there are many palettes better suited for visualization than “rainbow”, including sequential \"viridis\" and \"ag_sunset\" or diverging \"pu_gn\" and \"geyser\". All of them can be specified in tmap.3 More examples showing alternatives to the “rainbow” palette are in the documentation of the colorspace package at https://colorspace.r-forge.r-project.org/articles/endrainbow.html (Zeileis et al. 2019).\nBy default, the tmap package attempts to identify the type of variable used. For example, it uses \"area7\" for a categorical (unordered) variable, \"blues3\" for a sequential variable, and “pu_gn” for a diverging one (Figure 7.6). \n\ntm_shape(slo_regions) + \n  tm_polygons(\"pop_dens\")\n\nThere are three main ways to specify color palettes as an values argument of the tm_scale() family of functions.  This argument accepts (1) a vector of colors, (2) a palette function, or (3) one of the built-in palette names (Figure 7.6). A vector of colors can be specified using color names or hexadecimal representations (Figure 7.6). Importantly, the length of the provided vector does not need to be equal to the number of colors in the map legend. tmap automatically interpolates new colors when a smaller number of colors are provided.\n\ntm_shape(slo_regions) +\n  tm_polygons(\"pop_dens\",\n              fill.scale = tm_scale(values = c(\"yellow\", \"darkgreen\")))\n\nAnother approach is to provide the output of a palette function (Figure 7.6). In the example below, we derived seven colors from \"ag_GrnYl\" palette. This palette goes from green colors to yellow ones, however, we wanted to reverse the order of this palette. Thus, we also used the rev() function here.\n\ntm_shape(slo_regions) +\n  tm_polygons(\"pop_dens\", \n              fill.scale = tm_scale(values = rev(hcl.colors(7, \"ag_GrnYl\"))))\n\nThe last approach is to use one of the names of color palettes built in tmap (Figure 7.6). In this example, we used the \"brewer.yl_gn\" palette that goes from yellow to green.\n\ntm_shape(slo_regions) +\n  tm_polygons(\"pop_dens\",\n              fill.scale = tm_scale(values = \"brewer.yl_gn\"))\n\nIt is also possible to reverse the order of any named color palette by using the - prefix. Therefore, \"-yl_gn\" will return a palette going from green to yellow.\n\n\n\n\n\n\n\n\n\n(a) default sequential color palette\n\n\n\n\n\n\n\n\n\n(b) palette created based on provided vector of colors\n\n\n\n\n\n\n\n\n\n\n\n(c) palette created using the hcl.colors() function\n\n\n\n\n\n\n\n\n\n(d) one of the build-in palettes\n\n\n\n\n\n\nFigure 7.6: Examples of four ways of specifying color palettes\n\n\n\n\nThe default color palette for positive numerical variables is \"blues3\" as seen in Figure 7.7 (a). On the other hand, when the given variable has both negative and positive values, then tmap uses the \"pu_gn\" color palette, with purple colors below the midpoint value, light gray color around the midpoint value, and green colors above the midpoint value. The use of diverging color palettes can be adjusted using the midpoint argument. It has a value of 0 as the default, however, it is possible to change it to any other value. For example, we want to create a map that shows regions with population density (pop_dens) below and above the median value of about 101 people per square kilometer. To do that, we just need to set the midpoint argument to this value (Figure 7.7 (b)).\n\n# mean(slo_regions$pop_dens, na.rm = TRUE)\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\", \n              fill.scale = tm_scale(midpoint = 101))\n\n\n\n\n\n\n\n\n\n\n(a) the default sequential color palette\n\n\n\n\n\n\n\n\n\n(b) the diverging color palette around the midpoint value of 73\n\n\n\n\n\n\nFigure 7.7: Examples of maps with different midpoints used\n\n\nNow the regions with low population density are presented with purple colors, light gray areas represent countries with population density around the median value (the midpoint in our case), and the regions with high population density are represented by green colors.\nThe above examples all contain several polygons with missing values of a given variable. Objects with missing values are, by default, represented by gray color and a related legend label Missing. However, it is possible to change this color with the value.na argument and its label with label.na.\ntmap has a special way to manually set colors for categorical maps. It works by providing a named vector to the values argument. In this vector, the names of the categories from the categorical variable are the vector names, and specified colors are the vector values. You can see it in the example below, where we plot the \"region_group\" categorical variable (Figure 7.8). Each category in this variable (e.g., \"Central\") has a new, connected to it color (e.g., \"#7fbee9\").  \n\ntm_shape(slo_regions) + \n  tm_polygons(\"region_group\", \n    fill.scale = tm_scale(values = c(\n      \"Central\" = \"#7fbee9\",\n      \"East\" = \"#ffd14d\", \n      \"North\" = \"#14909a\",\n      \"South\" = \"#df5454\",\n      \"West\" = \"#7b1072\")\n    ))\n\n\n\n\n\n\nFigure 7.8: An example of a categorical map with manually selected colors.\n\n\n\n\n Finally, visualized colors can be additionally modified. It includes setting the col_alpha and fill_alpha arguments that represents the transparency of the used colors. By default, the colors are not transparent at all as the value of col_alpha and fill_alpha is 1. However, we can decrease this value to 0 – a total transparency. The col_alpha/ fill_alpha argument is useful in two ways: one – it allows us to see-through some large objects (e.g., some points below the polygons or a hillshade map behind the colored raster of elevation), second – it makes colors more subtle.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Visual variables</span>"
    ]
  },
  {
    "objectID": "visual-variables.html#sec-sizes",
    "href": "visual-variables.html#sec-sizes",
    "title": "7  Visual variables",
    "section": "\n7.4 Sizes",
    "text": "7.4 Sizes\n\nslo_cities = read_sf(\"data/slovenia/slo_cities.gpkg\")\n\nDifferences in sizes between objects are relatively easy to recognize on maps. Sizes can be used for points, lines (line widths), or text to represent quantitative (numerical) variables, where small values are related to small objects and large values are presented by large objects. Large sizes can also be used to attract viewers’ attention.\nBy default, tmaps present points, lines, or text objects of the same size. For example, tm_symbols() returns a map where each object is a circle with a consistent size4. We can change the sizes of all objects using the size argument (Figure 7.9 (a)).\n\ntm_shape(slo_cities) +\n  tm_symbols(size = 0.5) \n\nOn the other hand, if we provide the name of the numerical variable in the size argument (e.g., \"population\"), then symbol sizes are scaled proportionally to the provided values. Objects with small values will be represented by smaller circles, while larger values will be represented by larger circles (Figure 7.9 (b)).\n\ntm_shape(slo_cities) +\n  tm_symbols(size = \"population\") \n\n\n\n\n\n\nWe can adjust size legend breaks with ticks and the corresponding labels with labels (Figure 7.9 C) as arguments of the tm_scale function provided to the size.scale argument.\n\ntm_shape(slo_cities) +\n  tm_symbols(size = \"population\",\n            size.scale = tm_scale(ticks = c(50000, 300000),\n                                  labels = c(\"small\", \"large\")))\n\nFor example in the above code, we just show examples of how symbols with population values of 50,000 and 300,000 are represented on the map.\n\n\n\n\n\n\n\n\n\n(a) all symbols have a consistent size of 0.5\n\n\n\n\n\n\n\n\n\n(b) sizes of symbols depend on the values of the population variable\n\n\n\n\n\n\n\n\n\n(c) sizes of symbols have a manually created legend\n\n\n\n\n\n\nFigure 7.9: Examples of three approaches for changing sizes of symbols\n\n\nWidths of the lines can represent values of numerical variables for line data similar to sizes of the symbols for point data. The lwd argument in tm_lines() creates thin lines for small values and thick lines for large values of the given variable (Figure 7.10).\n\nslo_railroads = read_sf(\"data/slovenia/slo_railroads.gpkg\")\ntm_shape(slo_railroads) + \n  tm_lines(lwd = \"track_width\")\n\n\n\n\n\n\nFigure 7.10: Example of a map where lines’ widths represent values of the corresponding lines.\n\n\n\n\nIn the above example, values of the \"track_width\" are divided into five groups and represented by five line widths. Lines’ thickness can be change using the values.scale argument of tm_scale(), where the value of 1 is the default, and increasing this values increases lines’ thickness. \n\nText labels have a role in naming features on a map or just highlighting some of them. Usually, the size of text labels is consistent for the same spatial objects.  However, text labels can also be used to represent the values of some numerical variables. Figure 7.11 shows an example, in which text labels show names of different slo_cities areas, while their sizes are related to their elevations. \n\ntm_shape(slo_cities) +\n  tm_text(text = \"name\", size = \"population\") +\n  tm_layout(legend.outside = TRUE)\n\n\n\n\n\n\nFigure 7.11: Example of a map where text sizes represent elevations of the slo_cities.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Visual variables</span>"
    ]
  },
  {
    "objectID": "visual-variables.html#sec-shapes",
    "href": "visual-variables.html#sec-shapes",
    "title": "7  Visual variables",
    "section": "\n7.5 Shapes",
    "text": "7.5 Shapes\n\nShapes allow representing different categories of point data. They can be very generic, e.g., a circle or square, just to differentiate between categories, but often we use symbols that we associate with different types of features. For example, we use the letter P for parking lots, I for information centers, an airplane symbol for airports, or a bus symbol for bus stops.\nTo use different shapes, we should use the shape argument in the tm_symbols() function. It expects the name of the categorical variable, such as \"place\" in the example below (Figure 7.12 (a)).\n\ntm_shape(slo_cities) +\n  tm_symbols(shape = \"place\")\n\n\nBy default, tmap uses symbols of filled circle, square, diamond, point-up triangle, and point-down triangle5. However, it is also possible to customize the used symbols, their title, and labels. Legend titles related to shapes and their labels are modified with the shape.legend argument.\nShapes are specified with the shape.scale argument – there we can set the values argument with three different approaches: a vector of numbers, grob objects, or icons. The first one is a numeric value that specifies the plotting character of the symbol (Figure 7.12 (b)). A complete list of available symbols and their corresponding numbers is in the ?pch function’s documentation. \n\ntm_shape(slo_cities) +\n  tm_symbols(shape = \"place\",\n             shape.scale = tm_scale(values = c(0, 2)))\n\nThe second option is to use a graphic object (grob). It is a low-level graphical object in R that can be used to create custom shapes.   In the code below, we create two grob objects: a circle and a rectangle with custom sizes and colors. Then, we specify them in the shape.scale argument of the tm_symbols() function – see Figure 7.12 (c).\n\n# a circle\np1 = grid::circleGrob(r = 0.25, \n                      gp = grid::gpar(fill = \"skyblue\", col = \"darkblue\"))\n# a rectangle\np2 = grid::rectGrob(width = 0.5, height = 0.5, \n                    gp = grid::gpar(fill = \"lightgreen\", col = \"darkgreen\"))\n\ntm_shape(slo_cities) +\n  tm_symbols(shape = \"place\",\n             shape.scale = tm_scale(values = list(p1, p2)))\n\nThe last possibility is to use an icon specification created with the tmap_icons() function, which uses any PNG images. The tmap_icons() function accepts a vector of file paths or URLs, and also allows setting the width and height of the icon. In our example, we have two groups, therefore we need to create new icons based on two images – icon1.png and icon2.png in this case.\n\nmy_icons = tmap_icons(c(\"data/icon1.png\", \"data/icon2.png\"))\n\nNow, we can use the prepared icons in the shape.scale argument (Figure 7.12 (d)).\n\ntm_shape(slo_cities) +\n  tm_symbols(shape = \"place\",\n             shape.scale = tm_scale(values = my_icons))\n\n\n\n\n\n\n\n\n\n\n\n(a) default symbols\n\n\n\n\n\n\n\n\n\n(b) user-defined symbols\n\n\n\n\n\n\n\n\n\n\n\n(c) grob objects\n\n\n\n\n\n\n\n\n\n(d) icons\n\n\n\n\n\n\nFigure 7.12: Examples of maps with different symbols",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Visual variables</span>"
    ]
  },
  {
    "objectID": "visual-variables.html#sec-mixing-visual-variables",
    "href": "visual-variables.html#sec-mixing-visual-variables",
    "title": "7  Visual variables",
    "section": "\n7.6 Mixing visual variables",
    "text": "7.6 Mixing visual variables\nThe values of a given variable can be expressed by different categorical or sequential colors in polygons. Lines can be also colored by one variable, but also widths of the lines can represent values of another quantitative variable. When we use symbols, then we are able to use colors for one qualitative or quantitative variable, sizes for a quantitative variable, and shapes for another qualitative variable. Therefore, it is possible to mix some visual variables for symbols and lines. This section shows only some possible examples of mixing visual variables.\nFigure 7.13 (a) shows symbols, which sizes are scales based on the population variable and they are colored using the values from place. This can be set with the size and fill arguments.\n\ntm_shape(slo_cities) +\n  tm_symbols(size = \"population\",\n             fill = \"place\")\n\nWe can also modify all of the visual variables using the additional arguments explained in the next sections. For example, we can set the color style, color palette, or specify shapes (Figure 7.13 (b)).\n\ntm_shape(slo_cities) +\n  tm_symbols(fill = \"population\",\n             fill.scale = tm_scale(values = \"Greens\"),\n             shape = \"place\",\n             shape.scale = tm_scale(values = c(23, 24, 25)))\n\n\n\n\n\n\n\n\n\n\n(a) size and fill\n\n\n\n\n\n\n\n\n\n(b) fill and shape\n\n\n\n\n\n\nFigure 7.13: Examples of maps using two visual variables at the same time\n\n\nFor line data, we can present its qualitative and quantitative variables using colors and quantitative variables using sizes (line widths) (Figure 7.14).\n\n\n\n\n\n\n\nFigure 7.14: A map using two visual variables, color, and size (line width), at the same time.\n\n\n\n\n\n\n\n\nBirch, Jennifer. 2012. “Worldwide Prevalence of Red-Green Color Deficiency.” Journal of the Optical Society of America A 29 (3): 313. https://doi.org/10/ggkw82.\n\n\nBorland, David, and Russell Taylor Ii. 2007. “Rainbow Color Map (Still) Considered Harmful.” IEEE Computer Graphics and Applications 27 (2): 14–17. https://doi.org/10/cf7nms.\n\n\nCARTO. 2019. “CARTOColors Data-Driven Color Schemes.” https://carto.com/carto-colors/.\n\n\nCoombes, Kevin R., Guy Brock, Zachary B. Abrams, and Lynne V. Abruzzo. 2019. “Polychrome : Creating and Assessing Qualitative Palettes with Many Colors.” Journal of Statistical Software 90 (Code Snippet 1). https://doi.org/10/ggkqvs.\n\n\nCrameri, Fabio. 2018. “Geodynamic Diagnostics, Scientific Visualisation and StagLab 3.0.” Geoscientific Model Development 11 (6): 2541–62. https://doi.org/10/gdt4tg.\n\n\nGarnier, Simon. 2018. Viridis: Default Color Maps from ’Matplotlib’. https://CRAN.R-project.org/package=viridis.\n\n\nHarrower, Mark, and Cynthia A. Brewer. 2003. “ColorBrewer.org: An Online Tool for Selecting Colour Schemes for Maps.” The Cartographic Journal 40 (1): 27–37. https://doi.org/10/ch4c57.\n\n\nNeuwirth, Erich. 2014. RColorBrewer: ColorBrewer Palettes. https://CRAN.R-project.org/package=RColorBrewer.\n\n\nNowosad, Jakub. 2018. ’CARTOColors’ Palettes. https://nowosad.github.io/rcartocolor.\n\n\nNuñez, Jamie R., Christopher R. Anderton, and Ryan S. Renslow. 2018. “Optimizing Colormaps with Consideration for Color Vision Deficiency to Enable Accurate Interpretation of Scientific Data.” Edited by Jesús Malo. PLOS ONE 13 (7): e0199239. https://doi.org/10/gdzkg4.\n\n\nPedersen, Thomas Lin, and Fabio Crameri. 2020. Scico: Colour Palettes Based on the Scientific Colour-Maps. https://CRAN.R-project.org/package=scico.\n\n\nQuinan, P. S., L. M. Padilla, S. H. Creem-Regehr, and M. Meyer. 2019. “Examining Implicit Discretization in Spectral Schemes.” Computer Graphics Forum 38 (3): 363–74. https://doi.org/10/ggb9nd.\n\n\nSharpe, Lindsay T, Andrew Stockman, Herbert Jägle, and Jeremy Nathans. 1999. “Opsin Genes, Cone Photopigments, Color Vision, and Color Blindness.” In Color Vision: From Genes to Perception, edited by T Gegenfurtner and Lindsay T Sharpe, 50. Cambridge: Cambridge University Press.\n\n\nStauffer, Reto, Georg J. Mayr, Markus Dabernig, and Achim Zeileis. 2015. “Somewhere Over the Rainbow: How to Make Effective Use of Colors in Meteorological Visualizations.” Bulletin of the American Meteorological Society 96 (2): 203–16. https://doi.org/10/f3sttk.\n\n\nZeileis, Achim, Jason C. Fisher, Kurt Hornik, Ross Ihaka, Claire D. McWhite, Paul Murrell, Reto Stauffer, and Claus O. Wilke. 2019. “colorspace: A Toolbox for Manipulating and Assessing Colors and Palettes.” arXiv 1903.06490. arXiv.org E-Print Archive. http://arxiv.org/abs/1903.06490.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Visual variables</span>"
    ]
  },
  {
    "objectID": "visual-variables.html#footnotes",
    "href": "visual-variables.html#footnotes",
    "title": "7  Visual variables",
    "section": "",
    "text": "Other visual variables include position, orientation, and texture.↩︎\nLearn more about them at https://developer.r-project.org/Blog/public/2019/04/01/hcl-based-color-palettes-in-grdevices/ and https://developer.r-project.org/Blog/public/2019/11/21/a-new-palette-for-r/index.html.↩︎\nYou can also derive them using cols4all::c4a() function.↩︎\nThe default value of size is 1, which corresponds to the area of symbols that have the same height as one line of text.↩︎\nThey are represented in R by numbers from 21 to 25.↩︎",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Visual variables</span>"
    ]
  },
  {
    "objectID": "scales.html",
    "href": "scales.html",
    "title": "8  Scales",
    "section": "",
    "text": "8.1 Categorical scales\nSections 7.3, 7.4, and 7.5 showed how to set colors, sizes, and shapes for different types of spatial objects. In them, we often used the tm_scale() function to modify the appearance of the map, such as changing the color palette (col.scale and fill.scale), sizes (size.scale), or shapes (shape.scale). The tm_scale() function automatically sets the scale for the given visual variable and the data type (factor, numeric, and integer). Thus, for example, when we provide a character variable’s name to the fill argument, then the tm_scale() function automatically sets the color scale for a categorical variable, and when we provide a numeric variable’s name to the size argument, then the tm_scale() function automatically sets the size scale for a continuous variable.\nHowever, we often want to have more control over how our spatial objects are presented on the map. For that purpose, the tm_scale() function has a set of related functions that can be used to modify and customize the used scale. Table 8.1 presents all available scale functions in tmap.\nFigure 8.1 shows examples of how some of them look like when applied to the same variable.\nLet’s see how to use scales in the following sections – we will mostly focus on using scales for the fill.scale argument, but the same principles apply to the col.scale, size.scale, and shape.scale arguments.\nAn example of a categorical map can be seen in Figure 8.2. We created it by providing a character variable’s name, \"region_group\", in the fill argument.\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"region_group\")\n# same as:\n# tm_shape(slo_regions) +\n#   tm_polygons(fill = \"region_group\", fill.scale = tm_scale_categorical())\n\n\n\n\n\n\nFigure 8.2: Example of a map in which polygons are colored based on the values of a categorical variable.\nThe tm_polygons(fill = \"region_group\", fill.scale = tm_scale_categorical()) code is run automatically in the background in this case. It is possible to change the names of legend labels with the labels argument of the tm_scale() function. As mentioned in the Section 7.3 we can also change the used color palette with the values argument.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "scales.html#sec-ordinal-scales",
    "href": "scales.html#sec-ordinal-scales",
    "title": "8  Scales",
    "section": "\n8.2 Ordinal scales",
    "text": "8.2 Ordinal scales\nThe ordinal scale is similar to the categorical scale, but it is used for ordered categorical variables. By default, this scale uses a sequential color palette, which is suitable for ordered categorical variables Figure 8.3. We may use tm_scale_ordinal() when the order of the values matters to highlight some hierarchy or ranking.\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"region_group\",\n              fill.scale = tm_scale_ordinal())\n\n\n\n\n\n\nFigure 8.3: Example of a map in which polygons are colored based on the values of an ordered categorical variable.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "scales.html#sec-discrete-scales",
    "href": "scales.html#sec-discrete-scales",
    "title": "8  Scales",
    "section": "\n8.3 Discrete scales",
    "text": "8.3 Discrete scales\n\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"urbn_type\",\n              fill.scale = tm_scale_discrete())\n\n\n\n\n\n\nFigure 8.4: Example of a map in which polygons are colored based on the values of a discrete variable.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "scales.html#sec-rank-scales",
    "href": "scales.html#sec-rank-scales",
    "title": "8  Scales",
    "section": "\n8.4 Rank scales",
    "text": "8.4 Rank scales",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "scales.html#sec-intervals-scales",
    "href": "scales.html#sec-intervals-scales",
    "title": "8  Scales",
    "section": "\n8.5 Intervals scales",
    "text": "8.5 Intervals scales\n\n Intervals scales are used to represent continuous numerical variables using set of class intervals. In other words, values are divided into several groups based on their properties. Several approaches can be used to convert continuous variables to intervals, and each of them could result in different groups of values.  Most of them use the classInt package (Bivand 2020) in the background, therefore some additional information can be found in the ?classIntervals function’s documentation.\nBy default, the tm_scale_intervals() function is used in the background (Figure 8.5 (a)). It uses a style called “pretty”, which creates breaks that are whole numbers and spaces them evenly 1.\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\")\n\nIt is also possible to indicate the desired number of classes using the n argument of the tm_scale() function provided to the fill.scale argument. While not every n is possible depending on the input values, tmap will try to create a number of classes as close to possible to the preferred one.\nThe next approach is to manually select the limits of each break with the breaks argument of tm_scale() (Figure 8.5 (b)). This can be useful when we have some pre-defined breaks, or when we want to compare values between several maps. It expects threshold values for each break, therefore, if we want to have three breaks, we need to provide four thresholds. Additionally, we can add a label to each break with the labels argument.\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\", \n              fill.scale = tm_scale_intervals(\n                breaks = c(0, 100, 150, 250),\n                labels = c(\"low\", \"medium\", \"high\"))\n              )\n\nAnother approach is to create breaks automatically using one of many existing classification methods with the style argument of the tm_scale() function. Three basic methods are \"equal\", \"sd\", and \"quantile\" styles. Let’s consider a variable with 100 observations ranging from 0 to 10. The \"equal\" style divides the range of values into n equal-sized intervals. This style works well when the values change fairly continuously and do not contain any outliers. In tmap, we can specify the number of classes with the n argument or the number of classes will be computed automatically . For example, when we set n to 4, then our breaks will represent four classes ranging from 0 to 2.5, 2.5 to 5, 5 to 7.5, and 7.5 to 10. The \"sd\" style represents how much values of a given variable varies from its mean, with each interval having a constant width of the standard deviation. This style is used when it is vital to show how values relate to the mean. The \"quantile\" style creates several classes with exactly the same number of objects (e.g., spatial features), but having intervals of various lengths. This method has an advantage or not having any empty classes or classes with too few or too many values. However, the resulting intervals from the \"quantile\" style can often be misleading, with very different values located in the same class.\nTo create classes that, on the one hand, contain similar values, and on the other hand, are different from the other classes, we can use some optimization method. The most common optimization method used in cartography is the Jenks optimization method implemented at the \"jenks\" style (Figure 8.5 (c)).\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\", \n              fill.scale = tm_scale_intervals(style = \"jenks\"))\n\nThe Fisher method (style = \"fisher\") has a similar role, which creates groups with maximized homogeneity (Fisher 1958). A different approach is used by the dpih style, which uses kernel density estimations to select the width of the intervals (Wand 1997). You can visit ?KernSmooth::dpih for more details.\nAnother group of classification methods uses existing clustering methods. It includes k-means clustering (\"kmeans\"), bagged clustering (\"bclust\"), and hierarchical clustering (\"hclust\"). \nFinally, there are a few methods created to work well for a variable with a heavy-tailed distribution, including \"headtails\" and \"log10_pretty\". The \"headtails\" style is an implementation of the head/tail breaks method aimed at heavily right-skewed data. In it, values of the given variable are being divided around the mean into two parts, and the process continues iteratively for the values above the mean (the head) until the head part values are no longer heavy-tailed distributed (Jiang 2013). The \"log10_pretty\" style uses a logarithmic base-10 transformation (Figure 8.5 (d)). In this style, each class starts with a value ten times larger than the beginning of the previous class. In other words, each following class shows us the next order of magnitude. This style allows for a better distinction between low, medium, and high values. However, maps with logarithmically transformed variables are usually less intuitive for the readers and require more attention from them.\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\", \n              fill.scale = tm_scale_intervals(style = \"log10_pretty\"))\n\n\n\n\n\n\n\n\n\n\n\n(a) The “pretty” method\n\n\n\n\n\n\n\n\n\n(b) The “fixed” method\n\n\n\n\n\n\n\n\n\n\n\n(c) The “jenks” method\n\n\n\n\n\n\n\n\n\n(d) The “log10_pretty” method\n\n\n\n\n\n\nFigure 8.5: Examples of four methods of creating intervals maps",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "scales.html#sec-continuous-scales",
    "href": "scales.html#sec-continuous-scales",
    "title": "8  Scales",
    "section": "\n8.6 Continuous scales",
    "text": "8.6 Continuous scales\n Continuous maps also represent continuous numerical variables, but without any discrete class intervals (Figure 8.6). A few continuous methods exist in tmap, including tm_scale_continuous(), tm_scale_rank(), and tm_scale_continuous_log10().\nThe tm_scale_continuous() function creates a smooth, linear gradient. In other words, the change in values is proportionally related to the change in colors. We can see that in Figure 8.6 (a), where the value change from 50 to 100 has a similar impact on the color scale as the value change from 100 to 150. The continuous scale is similar to the pretty style, where the values also change linearly. The main difference between them is that we can see differences between, for example, values of 110 and 140 in the former, while both values have exactly the same color in the later one. The continuous scale works well in situations where there is a large number of objects in vectors or a large number of cells in rasters, and where the values change continuously (do not have many outliers).\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.scale = tm_scale_continuous())\n\nHowever, when the presented variable is skewed or have some outliers, we can use either tm_scale_rank() or tm_scale_continuous_log10(). The tm_scale_rank() scale also uses a smooth gradient with a large number of colors, but the values on the legend do not change linearly (Figure 8.6 (b)).  It is fairly analogous to the \"quantile\" style, with the values on a color scale that divides a dataset into several equal-sized groups.\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.scale = tm_scale_rank())\n\nFinally, the tm_scale_continuous_log10() scale is the continuous equivalent of the \"log10_pretty\" style of tm_scale_intervals() (Figure 8.6 (c)).\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.scale = tm_scale_continuous_log10())\n\n\n\n\n\n\n\n\n\n\n(a) The “continuous” method\n\n\n\n\n\n\n\n\n\n(b) The “rank” method\n\n\n\n\n\n\n\n\n\n(c) The “log10” method\n\n\n\n\n\n\nFigure 8.6: Examples of three methods of creating continuous maps",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "scales.html#sec-asis-scales",
    "href": "scales.html#sec-asis-scales",
    "title": "8  Scales",
    "section": "\n8.7 As-is scales",
    "text": "8.7 As-is scales\nIn most cases, we want to use a color scale based on the variable’s values. Then, tmap takes these values, groups them into classes, and assigns a color to each class. However, it is also possible to use the values of the variables directly to specify the fill color or other visual properties of the spatial objects. For example, your spatial vector data may contain a column with colors, such as \"blue\", \"red\", and \"green\", and then we want to use these colors directly to color the polygons. This is known as an as-is scale, and it can be used with the tm_scale_asis() function.\nFor example, let’s take a look at the urbn_type_col variable in the slo_regions dataset. It contains the names of the colors (in a hexadecimal format) that we want to use to color the polygons.\n\nslo_regions$urbn_type_col\n#&gt;  [1] \"#994F88\" \"#994F88\" \"#994F88\" \"#994F88\" \"#994F88\" \"#994F88\" \"#994F88\"\n#&gt;  [8] \"#994F88\" \"#2CA02C\" \"#2CA02C\" \"#994F88\" \"#2CA02C\"\n\nTo fill each polygon with the color specified in the urbn_type_col variable, we should specify that column with the fill argument of the tm_polygons() function and then set the fill.scale argument to tm_scale_asis() (Figure 8.7).\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"urbn_type_col\",\n              fill.scale = tm_scale_asis()) \n\n\n\n\n\n\nFigure 8.7: Example of a map in which polygons are directly colored based on the values of a variable (an as-is scale).\n\n\n\n\nThis scale does not return any legend – it is not needed, as the colors are already specified in the data.\nThe tm_scale_asis() function can be used not only for the fill argument, but also for the col, size, shape, and other similar arguments. In such cases, the values of the variable should be appropriate for the visual property, e.g., a set of colors for col or a set of numeric values, representing sizes, for size and, representing shapes for shape.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "scales.html#sec-rgb-scales",
    "href": "scales.html#sec-rgb-scales",
    "title": "8  Scales",
    "section": "\n8.8 RGB scales",
    "text": "8.8 RGB scales\n\nlibrary(stars)\nsat = read_stars(\"data/slovenia/slo_mosaic.tif\")\n\nThe sat object contains four bands of the Sentinel-2 image for Slovenia. The bands (blue, green, red, and near-infrared) are stored in the band dimension as B02, B03, B04, and B08. We can plot all of the bands independently or as a combination of three bands. This combination is known as a color composite image, and we can create such images with the tm_rgb() function (Figure 8.8).\nStandard composite image (true color composite) uses the visible red, green, and blue bands to represent the data in natural colors. We can specify which band in sat relates to red (third band), green (second band), and blue (first band) color in tm_rgb() with the tm_vars() function.    \n\ntm_shape(sat) +\n  tm_rgb(tm_vars(dimvalues = c(\"B04\", \"B03\", \"B02\"), n = 3, multivariate = TRUE),\n         col.scale = tm_scale_rgb(stretch = TRUE, probs = c(0.02, 0.98)))\n\n\n\n\n\n\n\nNote\n\n\n\nThe tm_vars() function allows to specify more than one variable to be visualized at the same time. This is useful when we want to present a few variables as facets or combine multiple variables or layers to create a color composite image (tm_rgb()), a bivariate map, or an animation. It has five arguments:\n\n\nx: variable names, variable indices, or a dimension name (for sf, stars, and SpatRaster objects)\n\ndimvalues: dimension values (for stars objects)\n\nn: (if specified) the first n variables that are used\n\nmultivariate: in case multiple variables are specified, should they serve as facets (FALSE; default) or as a multivariate visual variable?\n\nanimate: should the variable(s) be animated?\n\n\n\nTrue color images are straightforward to interpret and understand, but they make subtle differences in features challenging to recognize. However, nothing stops us from using the above tools to integrate different bands to create so called false color composites. Various band combinations emphasize some spatial characteristics, such as water, agriculture, etc., and allow us to visualize wavelengths that our eyes can not see.  Figure 8.8 (b) shows a composite of near-infrared, red, and green bands, highlighting vegetation with a bright red color.\n\ntm_shape(sat) +\n  tm_rgb(tm_vars(dimvalues = c(\"B08\", \"B04\", \"B03\"), n = 3, multivariate = TRUE),\n         col.scale = tm_scale_rgb(stretch = TRUE, probs = c(0.02, 0.98)))\n\n\n\n\n\n\n\n\n\n\n\n(a) True color composite image\n\n\n\n\n\n\n\n\n\n(b) False color composite image\n\n\n\n\n\n\nFigure 8.8: Two color composite images",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "scales.html#sec-bivariate-scales",
    "href": "scales.html#sec-bivariate-scales",
    "title": "8  Scales",
    "section": "\n8.9 Bivariate scales",
    "text": "8.9 Bivariate scales\n In cases when we have two variables that we want to visualize, the most common approach is to create two separate maps, one for each variable (Figure 8.9). We can do that using the tm_vars() function, which allows us to specify multiple variables (see the code below) or with the facet functions (see Chapter 16).\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = tm_vars(c(\"pop_dens\", \"pop65perc\")),\n              fill.scale = tm_scale(values = \"purples\"))\n\n\n\n\n\n\nFigure 8.9: Example of two separate maps, one for each variable.\n\n\n\n\n\nAnother approach is to create a bivariate map, where the two variables are combined into a single map. This is done by representing not only the values of each variable independently but also their interaction using a bivariate color scale. Figure 8.10 shows an example of a bivariate map, where the population density and the percentage of the population aged 65 and older are combined into a single map. Areas with a small population density and a small percentage of the population aged 65 and older are colored in gray, while areas with a high population density and a high percentage of the population aged 65 and older are colored in dark brown. Additionally, the areas with a high population density and a low percentage of the population aged 65 and older are colored in purple, while areas with a low population density and a high percentage of the population aged 65 and older are colored in gold.\nThe creation of bivariate maps is done with the tm_vars() function, where we specify the two variables we want to combine and set the multivariate argument to TRUE. Bivariate maps also require a special color palette, which can be specified with tm_scale_bivariate() provided to the *.scale argument.  Additionally, we can modify the *.legend argument with tm_legend_bivariate(). In the case of bivariate maps, the xlab and ylab arguments are used to add labels to the x and y axes of the legend, respectively.\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = tm_vars(c(\"pop_dens\", \"pop65perc\"), multivariate = TRUE),\n              fill.scale = tm_scale_bivariate(values = \"purplegold\"),\n              fill.legend = tm_legend_bivariate(xlab = \"Pop. 65+ %\", \n                                                ylab = \"Pop. density\\n(per sq. km)\"))\n\n\n\n\n\n\nFigure 8.10: Example of a bivariate map, where two variables are combined into a single map.\n\n\n\n\nThe map of a relationship between two variables can also be done for raster data, such as stars objects. Below, we read the monthly average temperature for Slovenia from a GeoTIFF file and then select only the two months of interest – January and July. Our aim is to visualize how winter and summer temperatures differ in Slovenia.\n\nlibrary(stars)\nslo_tavg = read_stars(\"data/slovenia/slo_tavg.tif\") \nslo_tavg = slo_tavg[,,,c(1, 7)]\n\n\nAs you can see below, the syntax to create a bivariate map using tm_vars() is the same as for vector data, except in this case, we use tm_raster() instead of tm_polygons() and provide our variables as a dimvalues argument of tm_vars() (Figure 8.11 (a)).\n\ntm_shape(slo_tavg) +\n  tm_raster(col = tm_vars(dimvalues = c(\"tavg_1\", \"tavg_7\"), \n                          multivariate = TRUE))\n\nOne important difference between a regular map and a bivariate map is that the latter is based on two scales – and we are able to specify them separately. Thus, all of the scales from sections 8.1 to 8.6 can be used for bivariate maps, and we can use one of them for each variable.  In the example below, we use two scales for the temperature – one for the January temperatures and one for the July temperatures. In both cases, our scales are intervals, but we customize their breaks and add text labels.\nAnother difference is that a regular color scale is one-dimensional – it has only one axis, and thus we can either use its original form (e.g., from light to dark blue) or flip it (e.g., from dark to light blue). A bivariate color scale, on the other hand, is two-dimensional. It has two axes, and this opens up many more possibilities for modifying the scale. In the example below, we are using the \"pinkblue\" color scale, which, by default, features a gray color at the bottom left, with the vertical axis transitioning to purple and the horizontal axis transitioning to green. The colors mix in the top right corner to form a dark blue. However, in our case, we may consider flipping this color scale along the main diagonal, so that the vertical axis transitions to green, while the horizontal one transitions to purple. This seems more intuitive, as the vertical axis represents January temperatures, which are typically colder than July temperatures in Slovenia.\n\ntm_shape(slo_tavg) +\n  tm_raster(col = tm_vars(\n              dimvalues = c(\"tavg_1\", \"tavg_7\"), \n              multivariate = TRUE\n            ),\n            col.scale = tm_scale_bivariate(\n              values = \"//pinkblue\",\n              scale1 = tm_scale_intervals(\n                breaks = c(-8, -4, 0, 4, 8), \n                labels = c(\"Very cold\", \"Cold\", \"Mild\", \"Warm\")\n              ),\n              scale2 = tm_scale_intervals(\n                breaks = c(5, 10, 15, 20, 25),\n                labels = c(\"Very cold\", \"Cold\", \"Mild\", \"Warm\")\n              )\n            ),\n            col.legend = tm_legend_bivariate(\n              xlab = \"July\", ylab = \"January\", reverse = FALSE\n            )\n          )\n\nFigure 8.11 (b) shows a customized bivariate map for the January and July temperatures in Slovenia. We may see that most of the country is characterized by mild temperatures in both months, while the cold temperatures are observed in the mountainous regions in the northwest, and the warm temperatures are observed in the southwest part of the country. There are also a few areas where the temperature category is very different between the two months, such as the northeastern part of the country, with warm July and cold January temperatures.\n\n\n\n\n\n\n\n\n\n(a) Simple map\n\n\n\n\n\n\n\n\n\n\n\n(b) Customized map\n\n\n\n\n\n\nFigure 8.11: Bivariate maps for raster data\n\n\n\nAll possible flipping operators for bivariate color scales are shown in Table 8.2.\n\n\n\nTable 8.2: Operators for flipping bivariate color scales\n\n\n\n\n    \n\n      \n\nOperator\n                Description\n              \n\n\n\n                  Normal order\n                \n\n-\n                  Flip columns (left-right)\n                \n\n|\n                  Flip rows (top-bottom)\n                \n\n+\n                  Flip rows and columns\n                \n\n//\n                  Flip main diagonal (top-left to bottom-right)\n                \n\n\\\\\n                  Flip other diagonal (top-right to bottom-left)\n                \n\n-//\n                  Flip main diagonal and columns\n                \n\n-\\\\\n                  Flip other diagonal and columns\n                \n\n\n\n\n\n\n\n\n\nAdditionally, Figure 8.12 shows how these flipping operators work in action on an example bivariate color scale.\n\n\n\n\n\n\n\nFigure 8.12: Bivariate color scales with different flipping operators\n\n\n\n\n\n\n\n\n\n\n\nBivand, Roger. 2020. classInt: Choose Univariate Class Intervals. https://CRAN.R-project.org/package=classInt.\n\n\nFisher, Walter D. 1958. “On Grouping for Maximum Homogeneity.” Journal of the American Statistical Association, 10. https://doi.org/10/gkb5sf.\n\n\nJiang, Bin. 2013. “Head/Tail Breaks: A New Classification Scheme for Data with a Heavy-Tailed Distribution.” The Professional Geographer 65 (3): 482–94. https://doi.org/10/f24r6j.\n\n\nWand, M. P. 1997. “Data-Based Choice of Histogram Bin Width.” The American Statistician 51 (1): 59. https://doi.org/10/fvsfdb.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "scales.html#footnotes",
    "href": "scales.html#footnotes",
    "title": "8  Scales",
    "section": "",
    "text": "For more information visit the ?pretty() function documentation↩︎",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scales</span>"
    ]
  },
  {
    "objectID": "legends.html",
    "href": "legends.html",
    "title": "\n9  Legends and titles\n",
    "section": "",
    "text": "9.1 Legends\nThis chapter covers legends and titles in tmap – how to create them, customize their appearance, and position them on the map. The examples in this chapter use the elevation raster data of Slovenia in meters above sea level (m asl).\nLegends are an essential part of most maps. They provide meaning to the symbols or colors used in the map, and often add information about the map content. They allow to interpret the map correctly, and are therefore crucial for the map readability.\nIn tmap, legends are created automatically when we add a layer with a data-driven visual variable. By default, such a legend consists of a title based on the variable name and a color/shape/symbol scale (Figure 9.1).  It is placed outside of the map frame, either on the right or on the bottom of the map, depending on the automatically determined map aspect ratio.\ntm_shape(slo_elev) +\n    tm_raster()\n\n\n\n\n\n\nFigure 9.1: A map with an automatically generated legend.\nSuch a legend is helpful for quick exploration of the data, but usually, they are not sufficient for sharing the map with others. This chapter covers how to customize the legend’s title, position, and appearance in tmap. Legends are also closely related to the visual variables and scales used in the map that were covered in chapters Chapter 7 and Chapter 8 – we recommend to read those chapters first.  Legends are customized using the tm_legend() function that is passed to *.legend arguments of the layer functions, e.g., col.legend, shape.legend, size.legend, etc.\nOften, the most important part of the legend is the title. It informs the reader about the meaning of the colors or symbols used in the map, providing also additional context such as the unit of measurement. The title is set using the title argument of the tm_legend() function (Figure 9.2 (a)).\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(title = \"Elevation (m asl)\")\n    )\nIn some cases, the title is not needed, e.g., when the map is self-explanatory, and then this argument can be set to \"\". Another possibility, when only one legend is used is to remove the legend title, but specify the map variable and its unit in the map title.\nThe legend title and its text can be customized in many ways, including changing its font size (title.size and text.size), font family (title.family and text.family), and font color (title.color and text.color).\nBy default, values in the legend are ordered from low to high (i.e., from top to bottom), but this can be reversed using the reverse argument (Figure 9.2 (b)).\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(title = \"Elevation (m asl)\", reverse = TRUE)\n    )\nIn our example of Slovenia, we have enough white space inside the map frame to place the legend. This can be done with the position argument of the tm_legend() function (Figure 9.2 (c)). To put the legend inside the map frame, we can use the tm_pos_in() function and specify the location of the legend using its first two arguments (Chapter 11).\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(\n            title = \"Elevation (m asl)\",\n            position = tm_pos_in(\"right\", \"bottom\")\n        )\n    )\nDepending on the map content, used colors, and expected aesthetic, the legend background can be colored or made transparent. The default legend background is white, but it can be changed using the bg.color argument of the tm_legend() function. In the following example, we set the background color to gray and also make it semi-transparent using the bg.alpha argument (Figure 9.3 (a)).\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(\n            title = \"Elevation (m asl)\",\n            position = tm_pos_in(\"right\", \"bottom\"),\n            bg.color = \"gray\",\n            bg.alpha = 0.5\n        )\n    )\nAll of the previous examples used the default legend orientation type, \"portrait\". Its alternative is \"landscape\", which can be set using the orientation argument of the tm_legend() function. This changes the legend layout to a horizontal orientation, which can be useful either as a mean to better fit to the map content or to change the map aesthetic.\nHere, we not only change the legend orientation, but also customize its position with tm_pos_out() (Chapter 11) 1. The three arguments used, \"center\", \"top\", and \"center\" specify the legend position in horizontal and vertical position outside the map frame and then its position relative to that placement (Figure 9.3 (b)).\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(\n            title = \"Elevation (m asl)\",\n            orientation = \"landscape\",\n            position = tm_pos_out(\"center\", \"top\", pos.h = \"center\")\n        )\n    )\nTo disable the legend, we can set the show argument of the tm_legend() function to FALSE (Figure 9.3 (c)). This is useful when we want to use the same legend for multiple layers, or just when we only are interested in the map content and not in the legend – which may be the case when we are using the map for graphical purposes only.\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(show = FALSE)\n    )",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Legends and titles</span>"
    ]
  },
  {
    "objectID": "legends.html#sec-legends",
    "href": "legends.html#sec-legends",
    "title": "\n9  Legends and titles\n",
    "section": "",
    "text": "(a) Legend with a custom title.\n\n\n\n\n\n\n\n\n\n(b) Legend with a custom title and reversed order.\n\n\n\n\n\n\n\n\n\n(c) Legend with a custom position inside the map frame.\n\n\n\n\n\n\nFigure 9.2: Legend customization examples.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Legend with a custom background color and transparency.\n\n\n\n\n\n\n\n\n\n(b) Legend with a custom orientation and position outside the map frame.\n\n\n\n\n\n\n\n\n\n(c) No legend.\n\n\n\n\n\n\nFigure 9.3: Additional legend customization examples.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Legends and titles</span>"
    ]
  },
  {
    "objectID": "legends.html#sec-titles",
    "href": "legends.html#sec-titles",
    "title": "\n9  Legends and titles\n",
    "section": "\n9.2 Titles",
    "text": "9.2 Titles\nTitles are another essential part of the map, as they can provide context and information about the map content. In tmap, titles are added with the tm_title() function.\n\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(title = \"Elevation (m asl)\")\n    ) +\n  tm_title(\"Slovenia\")\n\nTitles could serve as a few roles. They may provide a general description of the map content, such as the name of the area (Figure 9.4 (a)). Titles can also be used to replace the legend title (Figure 9.4 (b)) – then the reader can interpret the map content based on the title, which is more prominent than the legend title.\n\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(title = \"\")\n    ) +\n  tm_title(\"Elevation Map of Slovenia\")\n\n\n\n\n\n\n\n\n\n\n(a) Simple title\n\n\n\n\n\n\n\n\n\n(b) Title replacing the legend title\n\n\n\n\n\n\nFigure 9.4: Map title examples.\n\n\nTitles are text elements and therefore can be customized in many ways, including changing the font size (size), font color (color), and font face (fontface) (Figure 9.5 (a))\n\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(title = \"\")\n    ) +\n  tm_title(\"Elevation Map of Slovenia\", \n           size = 1.5,\n           color = \"gray10\",\n           fontface = \"bold\"\n           )\n\nWe can also add a background to the title, which can improve the visibility of the title text while providing a distinct aesthetic (Figure 9.5 (b)). A map title is treated as all of the rest of the map elements and, therefore, can be placed outside or inside of the map frame using the position argument of the tm_title() function (see Chapter 11 for more details).\n\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(title = \"\")\n    ) +\n  tm_title(\"Elevation Map of Slovenia\", \n           size = 1.5,\n           color = \"white\",\n           fontface = \"bold\",\n           bg = TRUE,\n           bg.color = \"black\",\n           position = tm_pos_out(\"center\", \"top\", pos.h = \"right\")\n           )\n\n\n\n\n\n\n\n\n\n\n(a) Title with custom font size, color, and face.\n\n\n\n\n\n\n\n\n\n(b) Title with custom font size, color, face, and background.\n\n\n\n\n\n\nFigure 9.5: Title customization examples.\n\n\nMany titles can be used in the same map, e.g., a main title and a subtitle (Figure 9.6). This can be done by adding multiple tm_title() functions to the map, which is placed on the top left of the map by default, and tm_title_in() function to place the title inside the top left corner of the map frame.\n\ntm_shape(slo_elev) +\n    tm_raster(\n        col.legend = tm_legend(title = \"\")\n    ) +\n  tm_title(\"Slovenia\") +\n  tm_title_in(\"Elevation Map\")\n\n\n\n\n\n\nFigure 9.6: A map with a title and a subtitle.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Legends and titles</span>"
    ]
  },
  {
    "objectID": "legends.html#footnotes",
    "href": "legends.html#footnotes",
    "title": "\n9  Legends and titles\n",
    "section": "",
    "text": "By default, the \"landscape\" legend is located in the bottom right outside of the map frame↩︎",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Legends and titles</span>"
    ]
  },
  {
    "objectID": "map-components.html",
    "href": "map-components.html",
    "title": "10  Map components",
    "section": "",
    "text": "10.1 Grid lines\nMap components are visual elements that are not directly related to the data-driven map layers while providing additional information or context to the map. They are not tied to the map’s coordinates but rather to the map’s layout and design. Table 10.1 shows the list of available map components in tmap. It includes functions that draw coordinate grid lines, latitude and longitude graticules, scale bars, north arrows, text annotations, logos, axis labels, and minimaps. We cover and demonstrate these functions in the following sections.\nFor the examples in this section, we will use a simple map of the Slovenia polygon (not shown).\nThe tmap package offers two ways to draws coordinate lines - tm_grid() and tm_graticules(). The role of tm_grid() is to represent the input data’s coordinates. For example, the slo_borders object’s CRS is ETRS89-extended / LAEA Europe with the units in meters (Figure 10.1 (a)), and thus the grid lines are in meters.\ntm_shape(slo_borders) +\n  tm_polygons() +\n  tm_grid()\ntm_graticules() shows longitude lines (meridians) and latitude lines (parallels), with degrees as units. This can be seen with the degree signs in the labels (Figure 10.1 (b)).\ntm_shape(slo_borders) +\n  tm_polygons() +\n  tm_graticules()\nBoth, tm_grid() and tm_graticules() can be placed above or below the map layers as their position on the map depends on their place in the code. When tm_grid() or tm_graticules() is placed after the map layer (e.g., tm_polygons()), the grid lines are plotted on the top of the map. On the other hand, when tm_grid() or tm_graticules() is placed before the map layer code, the grid lines are plotted behind the spatial data (Figure 10.1 (c)).\ntm_shape(slo_borders) +\n  tm_graticules() +\n  tm_polygons()\nGrids and graticules can also be easily customized using several arguments, such as, x and y (x and y coordinates of the lines), n.x and n.y (number of horizontal (x) and vertical (y) lines), labels.inside.frame, ticks, lines It is also possible to customize their appearance, for example, by changing the colors of the lines (col), width (lwd) or labels’ sizes (labels.size).",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Map components</span>"
    ]
  },
  {
    "objectID": "map-components.html#sec-grid-lines",
    "href": "map-components.html#sec-grid-lines",
    "title": "10  Map components",
    "section": "",
    "text": "(a) Grid lines\n\n\n\n\n\n\n\n\n\n(b) Graticules\n\n\n\n\n\n\n\n\n\n(c) Graticules behind the map layer\n\n\n\n\n\n\nFigure 10.1: Examples of grid lines and graticules.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Map components</span>"
    ]
  },
  {
    "objectID": "map-components.html#sec-scale-bar",
    "href": "map-components.html#sec-scale-bar",
    "title": "10  Map components",
    "section": "\n10.2 Scale bar",
    "text": "10.2 Scale bar\nScale bar is a graphic indicator of the relation between a distance on a map and the corresponding distance in the real world. Nowadays, it is more often used than a traditional representative fraction (e.g., 1:10000). Compared to the representative fraction, scale bars work correctly on variable screen sizes or different print sizes, as their sizes change together with the rest of the map.\nThe tm_scalebar() function adds a scale bar.   It is possible, however, to manually update the values of scale bar’s breaks with the breaks argument and its size with the text.size argument (Figure 10.2).\n\ntm +\n  tm_scalebar(breaks = c(0, 15, 30), text.size = 1)\n\n\n\n\n\n\nFigure 10.2: A map with a customized scale bar.\n\n\n\n\nThe tm_scalebar() also has several additional arguments, allowing to modify its colors and position.\nImportantly, the scale bar is accurate, depending on a map projection, at standard points or lines only (Section 13.4) – it is never completely correct across the whole map.  The scale bar distortion increases with the true size of the area we are mapping – it is less visible on local maps, and very prominent on global maps. For example, try to add a scale bar to a world map seen in the Section 5.1. The created scale bar will be accurate for the equator, but less and less correct going to the north and south poles.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Map components</span>"
    ]
  },
  {
    "objectID": "map-components.html#sec-north-arrow",
    "href": "map-components.html#sec-north-arrow",
    "title": "10  Map components",
    "section": "\n10.3 North arrow",
    "text": "10.3 North arrow\nNorth arrow, also known as a map compass or a compass rose, is a prominent orientation indicator pointing to which way is north1. The decision on whether to use north arrows or not usually requires some critical thinking. While, it can be added to every map, north arrows are not always necessary – especially on maps of large areas (e.g., continents), where the cardinal directions are obvious for most people. The north arrow is, however, necessary when the north on the map is offset (rotated) and recommended when we want to help orient the map readers.\nWe can use the tm_compass() function to add the north arrow (Figure 10.3). By default, its north is oriented toward the top of the map (the north argument of 0), and the north arrow is represented by an actual arrow (the type argument of \"arrow\").\n\ntm +\n  tm_compass(type = \"4star\", size = 2, position = c(\"left\", \"top\"))\n\n\n\n\n\n\nFigure 10.3: A map with customized north arrow.\n\n\n\n\ntmap offers also a few other north arrow types, including \"arrow\", \"4star\", \"8star\", \"radar\", and \"rose\" (Figure 10.4). The north arrow can be also further customized with the size, show.labels and cardinal.directions arguments, and its colors may be modified (text.color, color.dark, color.light) (Figure 10.3). The location of the north arrow, by default, is placed automatically, but can also be changed using the position argument.     \n\n\n\n\n\n\n\nFigure 10.4: North arrow types\n\n\n\n\nThe position argument also works in the same way in other functions, such as tm_scalebar(), tm_credits(), tm_logo(), and in some of the tm_layout() arguments: legend.position, title.position, or chart.position.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Map components</span>"
    ]
  },
  {
    "objectID": "map-components.html#sec-text-annotation",
    "href": "map-components.html#sec-text-annotation",
    "title": "10  Map components",
    "section": "\n10.4 Text annotation",
    "text": "10.4 Text annotation\n\nText annotations, also known as map credits, are used to store additional information about the created map. They can include the source of data, the name of the author, the date of map creation, or information about the map projection. Text annotations are created with the tm_credits() function, which can be used more than one time (Figure 10.5).\n\ntm +\n  tm_credits(\"Data source: \", fontface = \"italic\") +\n  tm_credits(\"Author: \", fontface = \"bold\")\n\n\n\n\n\n\nFigure 10.5: A map with placeholders for text annotations.\n\n\n\n\nThe first argument of tm_credits() is the text, which can be spread over multiple lines with the line break symbol \\n. When the created map has several facets (Chapter 16), it is also possible to provide each facet a different text. In that case, a vector of characters is expected, where you can use \"\" to omit the credits for specific facets. Text annotations can also be further customized, by changing their sizes (size), colors (color), positions, and fonts (Section 12.3.3).",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Map components</span>"
    ]
  },
  {
    "objectID": "map-components.html#sec-axis-labels",
    "href": "map-components.html#sec-axis-labels",
    "title": "10  Map components",
    "section": "\n10.5 Axis labels",
    "text": "10.5 Axis labels\nThe tm_xlab() and tm_ylab() functions add x and y axis labels to the map. These labels can be used to describe the coordinates of the map, such as longitude and latitude, or faceting variables (Section 16.4).\n\ntm +\n  tm_xlab(\"X coordinates\") +\n  tm_ylab(\"Y coordinates\")\n\n\n\n\n\n\nFigure 10.6: A map with x and y axis labels.\n\n\n\n\nBy default, the x and y-axis labels are placed at the bottom and left sides of the map, respectively, in a horizontal orientation. The additional arguments of these functions allow to change the labels’ size, color, rotation, space between the labels and the map, and their side.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Map components</span>"
    ]
  },
  {
    "objectID": "map-components.html#sec-logo",
    "href": "map-components.html#sec-logo",
    "title": "10  Map components",
    "section": "\n10.6 Logo",
    "text": "10.6 Logo\nLogos on maps can serve a similar purpose as text annotation or accompany them. They can represent your affiliation, funding institution, data sources logos, etc. The tm_logo() function adds png images, either from a file or url, to the map (Figure 10.7).\n\ntm +\n  tm_logo(\"https://www.r-project.org/logo/Rlogo.png\",\n          height = 2) +\n  tm_logo(c(\"https://www.r-project.org/logo/Rlogo.png\",\n            \"https://www.r-project.org/logo/Rlogo.png\"),\n          height = 1)\n\n\n\n\n\n\nFigure 10.7: A map with an array of R logos.\n\n\n\n\nThere are two ways to use multiple logos. Many tm_logo() functions will places logos on top of each other, while providing a vector of png files will show them next to each other. Additional arguments include the height of the logo (height, the width is scaled automatically) and its position (position).",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Map components</span>"
    ]
  },
  {
    "objectID": "map-components.html#sec-minimap",
    "href": "map-components.html#sec-minimap",
    "title": "10  Map components",
    "section": "\n10.7 Minimap",
    "text": "10.7 Minimap\nThe minimap is a small overview map that shows the extent of the main map within a larger context. The tm_minimap() function adds a minimap of a globe to the main map, as illustrated in Figure 10.8.\n\ntm + \n  tm_minimap()\n\n\n\n\n\n\nFigure 10.8: A map with a minimap.\n\n\n\n\nThe tm_minimap() function is simple and straightforward, but does not offer too many customization options. If you want to create a more advanced minimap, you can use the tm_inset() function, which is described in Section 15.1.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Map components</span>"
    ]
  },
  {
    "objectID": "map-components.html#footnotes",
    "href": "map-components.html#footnotes",
    "title": "10  Map components",
    "section": "",
    "text": "Orientation may also be shown by graticule or grid lines (Section 10.1).↩︎",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Map components</span>"
    ]
  },
  {
    "objectID": "positions.html",
    "href": "positions.html",
    "title": "11  Positions",
    "section": "",
    "text": "11.1 Positioning\nThis chapter focuses on how to move map components, such as legends, scale bars, and insets, freely in the map. They can be placed both inside and outside the map frame – with some being in and some being out (Section 11.1). Moreover, map components can be grouped together, which allows them to be moved and arranged as a single unit (Section 11.2).\nTo demonstrate the positioning of map components, we will use a simple map with the elevation raster data of Slovenia in meters above sea level (m asl).\nAll of the map components can be positioned in any location in the map frame or outside of it. The positioning is done via the position argument, which can take a variety of values. The most common are:\nBoth functions can take additional arguments to control the position more precisely, including their justification and alignment.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Positions</span>"
    ]
  },
  {
    "objectID": "positions.html#sec-positioning",
    "href": "positions.html#sec-positioning",
    "title": "11  Positions",
    "section": "",
    "text": "tm_pos_in(): a function that allows to control the position inside the map frame (Figure 11.1). The first argument is the horizontal position and the second is the vertical position. E.g., tm_pos_in(\"left\", \"top\") locates a component in the top left corner of the map frame. This function can be used directly or through a shortcut – a character vector with two elements, where the first is the horizontal position and the second is the vertical position inside the map frame, e.g., c(\"left\", \"top\").\n\ntm_pos_out(): a function that allows the control of the position outside the map frame. For example, tm_pos_out(\"center\", \"top\") places a component in the center of the top side of the map frame.\n\n\n\n\n11.1.1 Inside the map frame\n\n\n\n\n\n\n\nFigure 11.1: Examples of positioning map components inside the map frame.\n\n\n\n\nMap legends, by default, are placed outside of the map frame – that is often expected as it does not overlap with the rest of the map content. However, we can find ourselves in a situation when our spatial data is so sparse that the legend can be placed inside the map, filling a white space. Then, we need to use the position argument of tm_legend().\nWe may use it either with a vector with two elements, or with the tm_pos_in() function (Figure 11.1). For example, position = c(\"right\", \"bottom\") or position = tm_pos_in(\"right\", \"bottom\") are equivalent. The first element of the vector is the horizontal position and the second is the vertical position inside the map frame. These elements can be either in lower case letters, UPPER CASE LETTERS, or numbers between 0 and 1.\nLowercase letters, e.g., \"right,\" \"bottom\", place the selected map component in the right bottom corner but leave some margin to the map frame (Figure 11.2 (a)).\n\ntm_shape(slo_elev) +\n    tm_raster(col.legend = tm_legend(position = c(\"right\", \"bottom\")))\n# same as:\n# tm_shape(slo_elev) +\n#     tm_raster(col.legend = tm_legend(position = tm_pos_in(\"right\", \"bottom\")))\n\nUppercase letters, e.g., \"RIGHT,\" \"BOTTOM\", also places the map component in the bottom right corner but directly touch the map frame (Figure 11.2 (b)).\n\ntm_shape(slo_elev) +\n    tm_raster(col.legend = tm_legend(position = c(\"RIGHT\", \"BOTTOM\")))\n\nNumbers between 0 and 1, e.g., c(0.8, 0.4) places the map component in the right bottom corner but with a margin of 20% of the map frame size (Figure 11.2 (c)).\n\ntm_shape(slo_elev) +\n    tm_raster(col.legend = tm_legend(position = c(0.8, 0.4)))\n\n\n\n\n\n\n\n\n\n\n(a) With lowercase letters: “right”, “bottom”\n\n\n\n\n\n\n\n\n\n(b) With uppercase letters: “RIGHT”, “BOTTOM’”\n\n\n\n\n\n\n\n\n\n(c) With numbers: 0.8, 0.4\n\n\n\n\n\n\nFigure 11.2: Positioning legends inside the map frame.\n\n\nThere is one important difference between specifying the position with a vector and with the tm_pos_in() function. The latter allows to control the position more precisely with additional arguments – just.h, just.v, align.h, and align.v. The just.h and just.v only work when the position is specified with numbers between 0 and 1, and they arguments control the justification of the map component to that position.\nThe align.h and align.v arguments are used when many map components are grouped together, which is explained in Section 11.2.\n\n11.1.2 Outside the map frame\n\n\n\n\n\n\n\nFigure 11.3: Examples of positioning map components outside the map frame.\n\n\n\n\nIn general, there are eight locations for map components outside the map frame – each of them can be specified with tm_pos_out() (Figure 11.3). We may place a map component either on one of the sides of the map frame (e.g., tm_pos_out(\"center\", \"top\")), or in its corner (e.g., tm_pos_out(\"left\", \"top\")).\nAt the same time, placing a map component outside a map frame brings some additional complexity. Now, we can not only put a component in a specified place, but also arrange it in that place. For example, tm_pos_out(\"center,\" \"top\") puts the specified component to the top of the map frame but is positioned to the left. What should we do if we want to center it?\nThe tm_pos_out() has four sets of arguments that control the position of a map component outside the map frame:\n\n\ncell.h and cell.v: the horizontal and vertical position of the map component outside the map frame.\n\npos.h and pos.v: the horizontal and vertical position of the map component inside the cell defined by cell.h and cell.v.\n\njust.h and just.v: the justification of the map components in relation to the position of the map component inside the cell – only used when pos.h and pos.v are specified as numbers between 0 and 1.\n\nalign.h and align.v: the alignment of the components is only used when many components are grouped together (Section 11.2).\n\nLet’s see how these arguments work in practice. The cell.h and cell.v arguments are the first two arguments of the tm_pos_out() function and they define the cell in which the map component will be placed (Figure 11.4 (a); Figure 11.4 (b)).\n\ntm_shape(slo_elev) +\n    tm_raster(col.legend = tm_legend(position = tm_pos_out(\"center\", \"bottom\")))\n\n\ntm_shape(slo_elev) +\n    tm_raster(col.legend = tm_legend(position = tm_pos_out(\"left\", \"center\")))\n\nThen, we may to control the location of the map component inside the cell with pos.h and pos.v arguments. The pos.h argument controls the horizontal position of the map component inside the cell, while the pos.v argument – the vertical position. The former is mostly useful when our legend is on the top of the map frame and the latter is useful when it is on the left or right side of the map frame (Figure 11.4 (c); Figure 11.4 (d)).\n\ntm_shape(slo_elev) +\n    tm_raster(col.legend = tm_legend(position = tm_pos_out(\"center\", \"bottom\", pos.h = \"center\")))\n\n\ntm_shape(slo_elev) +\n    tm_raster(col.legend = tm_legend(position = tm_pos_out(\"left\", \"center\", pos.v = \"center\")))\n\n\n\n\n\n\n\n\n\n\n(a) With cell.h = \"center\" and cell.v = \"bottom\"\n\n\n\n\n\n\n\n\n\n(b) With cell.h = \"left\" and cell.v = \"center\"\n\n\n\n\n\n\n\n\n\n\n\n(c) With pos.h = \"center\" in cell (cell.h = \"center\", cell.v = \"bottom\")\n\n\n\n\n\n\n\n\n\n(d) With pos.v = \"center\" in cell (cell.h = \"left\", cell.v = \"center\")\n\n\n\n\n\n\nFigure 11.4: Positioning legends outside the map frame.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Positions</span>"
    ]
  },
  {
    "objectID": "positions.html#sec-position-many-components",
    "href": "positions.html#sec-position-many-components",
    "title": "11  Positions",
    "section": "\n11.2 Many components",
    "text": "11.2 Many components\nVarious map components can be positioned at the same time – either to different locations or to the same one. For example, we can place a scale bar outside the map frame and a legend inside the map frame (Figure 11.5 (a)).\n\ntm_shape(slo_elev) +\n  tm_raster(col.legend = tm_legend(position = c(\"right\", \"bottom\"))) +\n  tm_scalebar(position = tm_pos_out(\"left\", \"center\"))\n\nNow, you may be wondering what happens if we want to place two (or more) components in the same location. As you can see in Figure 11.5 (b), they will be stacked on top of each other inside one frame.\n\ntm_shape(slo_elev) +\n  tm_raster(col.legend = tm_legend(position = tm_pos_out(\"right\", \"center\"))) +\n  tm_scalebar(position = tm_pos_out(\"right\", \"center\"))\n\n\n\n\n\n\n\n\n\n\n(a) Two components in different locations\n\n\n\n\n\n\n\n\n\n(b) Two components in the same location\n\n\n\n\n\n\nFigure 11.5: Positioning many map components.\n\n\nThe tmap package also has a mechanism to group map components together and then position and organize them as a single unit. This requires two steps:\n\nSpecifying the group_id argument in the map component that we want to group together – this should be a unique integer number.\nUsing the tm_components() function to select which group of map components we want to position together and where.\n\nIn the following example, we have three map components – a legend, a scale bar, and credits – and we want to group the scale bar and credits (Figure 11.6 (a)). First, we specify the group_id argument in the map components functions, and then we use the tm_components() function to position them together. Here, the position argument works exactly as we already described in the previous sections, i.e., it can be specified with a vector or with the tm_pos_in() or tm_pos_out() functions.\n\ntm_shape(slo_elev) +\n  tm_raster(col.legend = tm_legend(group_id = 1)) +\n  tm_scalebar(group_id = 2) +\n  tm_credits(\"My credits\", group_id = 2) +\n  tm_components(1, position = tm_pos_in(\"right\", \"bottom\")) +\n  tm_components(2, position = tm_pos_in(\"left\", \"top\"))\n\nThe tm_components() function can also be used to customize the arrangement of map components in the same location. For example, we can stack them vertically (stack = \"vertical\", default) or horizontally (stack = \"horizontal\") (Figure 11.6 (b)).\n\ntm_shape(slo_elev) +\n  tm_raster(col.legend = tm_legend(group_id = 1)) +\n  tm_scalebar(group_id = 2) +\n  tm_credits(\"My credits\", group_id = 2) +\n  tm_components(1, position = tm_pos_in(\"right\", \"bottom\")) +\n  tm_components(2, position = tm_pos_in(\"left\", \"top\"), stack = \"horizontal\")\n\n\n\n\n\n\n\n\n\n\n(a) Two groups of map components in different locations\n\n\n\n\n\n\n\n\n\n(b) Two groups of map components in the same location, one stacked horizontally\n\n\n\n\n\n\nFigure 11.6: Grouping map components together.\n\n\nEach additional map component is placed on the bottom of the previous one if they are in the same location. This can be controlled with the z argument of the map component functions – lower the number the component is placed on the top.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Positions</span>"
    ]
  },
  {
    "objectID": "layout.html",
    "href": "layout.html",
    "title": "12  Map layout",
    "section": "",
    "text": "12.1 Colors\nMap layout relates to all of the visual aspects of the created plot except the visual variables (Chapter 7), legends (Section 9.1), and map components (Chapter 10). It includes the map background, frame, typography, scale, aspect ratio, margins, and more.\nWe can customize the map layout using the tm_layout() function. In this chapter, we cover the most often used arguments of this function using a map of Slovenia’s regions as an example (Figure 12.1).\nThe most basic map layout customization is the color of the map background. Actually, there are a few separate zones on the map that can be colored – it includes, among others, the map background, the outer space background, and the map legend background (Figure 12.2). They can be customized with the bg.color, outer.bg.color, and legend.bg.color arguments of the tm_layout() function.\ntm + \n  tm_layout(bg.color = \"lightgreen\",\n            outer.bg.color = \"forestgreen\",\n            legend.bg.color = \"lightblue\")\n\n\n\n\n\n\nFigure 12.2: Customized map layout colors: background, outer space, and legend background.\nThe tm_layout() function also has tools to modify the complete map color style with arguments such as color.saturation, color.sepia_intensity, and color_vision_deficiency_sim. The first one represents the saturation of all colors on the map, including the backgrounds, as well as visual variables such as the fill or color of polygons and lines. The color.saturation parameter accepts a value between 0 and 1, where 0 means no color saturation (i.e., the map is black and white), and 1 means full-color saturation (i.e., the map is colorful, default) (Figure 12.3).\nThe color.sepia_intensity argument allows to apply a sepia filter to the map.  Its value can be set between 0 and 1, where 0 means no sepia filter (i.e., the map is colorful, default), and 1 means full sepia filter (i.e., the map is brownish) (Figure 12.4).\nBoth of the above options aim to change the overall map look and feel. The color_vision_deficiency_sim has a different purpose: it enables us to visualize how the map would appear to people with different color vision deficiencies. Three main types of color vision deficiencies are: protanopia (red-green color blindness, \"protan\"), deuteranopia (red-green color blindness, \"deutan\"), and tritanopia (blue-yellow color blindness, \"tritan\").",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Map layout</span>"
    ]
  },
  {
    "objectID": "layout.html#sec-lcolors",
    "href": "layout.html#sec-lcolors",
    "title": "12  Map layout",
    "section": "",
    "text": "tm + \n  tm_layout(color.saturation = 0)\ntm + \n  tm_layout(color.saturation = 0.4)\ntm + \n  tm_layout(color.saturation = 0.7)\n\n\n\n\n\n\n\n\n\n(a) Value: 0\n\n\n\n\n\n\n\n\n\n(b) Value: 0.4\n\n\n\n\n\n\n\n\n\n(c) Value: 0.7\n\n\n\n\n\n\nFigure 12.3: Impact of the color.saturation argument on the map layout.\n\n\n\ntm + \n  tm_layout(color.sepia_intensity = 0.4)\ntm + \n  tm_layout(color.sepia_intensity = 0.7)\ntm + \n  tm_layout(color.sepia_intensity = 1)\n\n\n\n\n\n\n\n\n\n(a) Value: 0.4\n\n\n\n\n\n\n\n\n\n(b) Value: 0.7\n\n\n\n\n\n\n\n\n\n(c) Value: 1\n\n\n\n\n\n\nFigure 12.4: Impact of the color.sepia_intensity argument on the map layout.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Value: \"protan\"\n\n\n\n\n\n\n\n\n\n(b) Value: \"deutan\"\n\n\n\n\n\n\n\n\n\n(c) Value: \"tritan\"\n\n\n\n\n\n\nFigure 12.5: Impact of the color_vision_deficiency_sim argument on the map layout.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Map layout</span>"
    ]
  },
  {
    "objectID": "layout.html#sec-lframe",
    "href": "layout.html#sec-lframe",
    "title": "12  Map layout",
    "section": "\n12.2 Frame",
    "text": "12.2 Frame\nAnother possibility to change the map look is to customize the frame around the map content. Its style depends on several arguments of the tm_layout() function. For example, frame.color, frame.alpha, and frame.lwd change the frame color, transparency (0-1), and line width, respectively (Figure 12.6 (a)). \n\ntm + \n  tm_layout(frame.color = \"black\",\n            frame.alpha = 0.6,\n            frame.lwd = 8)\n\nOther arguments that can be used to customize the frame are frame.r and frame.double_line (Figure 12.6 (b)). The first one makes the corners of the frame rounded – the value of 0 means no rounding, while 30 means that the corners are rounded with a radius of 30.    The second one allows to add a second frame line around the frame.\n\ntm + \n  tm_layout(frame.r = 30,\n            frame.double_line = TRUE)\n\nFinally, we can remove the frame completely by setting the frame argument to FALSE (Figure 12.6 (c)). \n\ntm + \n  tm_layout(frame = FALSE)\n\n\n\n\n\n\n\n\n\n\n(a) No frame\n\n\n\n\n\n\n\n\n\n(b) Custom color, alpha, and width\n\n\n\n\n\n\n\n\n\n(c) Rounded double line\n\n\n\n\n\n\nFigure 12.6: Impact of the frame arguments on the map layout.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Map layout</span>"
    ]
  },
  {
    "objectID": "layout.html#sec-ltypography",
    "href": "layout.html#sec-ltypography",
    "title": "12  Map layout",
    "section": "\n12.3 Typography",
    "text": "12.3 Typography\n\nThe decision about the used fonts is often neglected when creating programmable plots and maps. Most often, the default fonts are used in these kinds of graphs. This, however, could be a missed opportunity. A lot of map information is expressed by text, including text labels (Section 6.4), legend labels, text in map components (Chapter 10), or the map title (Section 9.2). The used fonts impact the tone of the map (Guidero 2017), and their customization allows for a map to stand out from maps using default options.\n\n\nAs we mentioned above, many different map elements can be expressed or can use fonts. In theory, we are able to set different fonts to each of them. However, this could result in a confusing visual mix that would hinder our map information. Therefore, the decision on the used fonts should be taken after considering the main map message, expected map audience, other related graph styles, etc. In the following three sections, we explain font families and font faces, and give some overall tips on font selections, show how to define used fonts, and how to customize fonts on maps.\n\n12.3.1 Font families and faces\n\n\n\n\n\n\n\n\n\n(a) Font families\n\n\n\n\n\n\n\n\n\n(b) Font faces\n\n\n\n\n\n\nFigure 12.7: Basic font families, and font faces implemented in the tmap package.\n\n\nIn tmap, fonts are represented by a font family (Figure 12.7 (a)) and a font face (Figure 12.7 (b)). A font family is a collection of closely related lettering designs. Examples of font families include Times, Helvetica, Courier, Palatino, etc. On the other hand, font faces, such as italic or bold, influence the orientation or width of the fonts. A font is, thus, a combination of a selected font family and font face.\nThere are a few general font families, such as serifs, sans serifs, and monospaced fonts. Fonts from the serif family have small lines (known as a serif) attached to the end of some letters. Notice, for example, short horizontal lines on the bottom of letters r, i, and f or vertical lines at the ends of the letter s in the top row of Figure 12.7 (a). The fonts in this family are often viewed as more formal. On the other hand, the sans serif family do not have serifs and is considered more informal and modern. The last font family, monospaced fonts, is often used in computer programming (IDEs, software text editors), but less often on maps. A distinguishing feature of the monospaced fonts is that each letter or character in this family has the same width. Therefore, letters, such as i and a will occupy the same space in the monospaced fonts. \nMixing the use of serif and sans serif fonts often works well for maps. However, a rule of thumb is not to mix more than two font families on one map. A sans serif font can be used to label cultural objects, while serif fonts to label physical features. Then, italics, for example, can be used to distinguish water areas. The role of bold font faces, together with increased font size, is to highlight the hierarchy of labels – larger, bold fonts indicate more prominent map features. Additionally, customizing the fonts’ colors can be helpful to distinguish different groups of map objects. \nThe decision on which fonts to use should also relates to the expected map look and feel. Each font family has a distinct personality (creates a “semantic effect”), which can affect how the map is perceived.  Some fonts are more formal, some are less. Some fonts have a modern look, while others look more traditional.  Another important concern is personal taste or map branding. We should filter the decision about the used fonts based on our preferences or even our sense of beauty as it could create more personal and unique maps. We just need to remember about the readability of the fonts – they should not be too elaborate as it can hinder the main map message.\n\n\n12.3.2 Fonts available in tmap\n\nBefore we discuss how to set a font family and its face, it is important to highlight that a different set of fonts could exist for each operating system (and even each computer). Additionally, which fonts are available and how they are supported depends on the used graphic device. A graphic device is a place where a plot or map is rendered. The most commonly it is a some kind of a screen device, where we can see our plot or map directly after running the R code. Other graphic devices allow for saving plots or maps as files in various formats (e.g., .png, .jpg, .pdf). Therefore, it is possible to get different fonts on your map on the screen, and a (slightly) different one when saved to a file. Visit ?Devices or read the Graphic Devices chapter of Peng (2016) to learn more about graphic devices.\nThe tmap package has two mechanism to select a font family. The first one is by specifying on of three general font families: \"serif\", \"sans\", or \"monospace\". It tries to match selected general font family with a font family existing on the operating system.  For example, \"serif\" could the \"Times\" font family, \"sans\" – \"Helvetica\" or \"Arial\", and \"monospace\" – \"Courier\" (Figure 12.7 (a)). The second mechanism allows to select a font family based on its name (e.g., \"Times\" or \"Palatino\"). Next, a member of the selected font families can be selected with one of the font faces: \"plain\", \"italic\", \"bold\", and \"bold.italic\" (Figure 12.7 (b)).\n\nAs mentioned before, available fonts depend on the computer setup (including operating system) and used graphic device. Fonts available on the operating system can be checked with the system_fonts() function of the systemfonts package (Pedersen, Ooms, and Govett 2021) (result not shown).\n\nlibrary(systemfonts)\nsystem_fonts()\n\nInformation on installing and debugging custom fonts can be found in a blog post by June Choe and in the showtext package (Qiu and See file AUTHORS for details. 2021) documentation.\nThe next step is to either view or save the map. This also means that we need to carry over our fonts to the output window/file, which largely depends on the selected graphic device. In general, screen device or graphical raster output formats, such as PNG, JPEG, or TIFF, works well with custom fonts as they rasterize them during saving. In case of any problems with graphical raster outputs, it is possible to try alternative graphics devices implemented in the ragg package (Pedersen and Shemanarev 2021). On the other hand, graphical vector formats, such as PDF or SVG, could have some problems with saving maps containing custom fonts1. The PDF device in R, by default, adds metadata about the used fonts, but does not store them. When the PDF reader shows the document, it tries to locate the font on your computer, and use other fonts when the expected one does not exist. An alternative approach is called embedding, which adds a copy of each necessary font to the PDF file itself. Gladly, the creation of a PDF with proper fonts can be achieved in a few ways. Firstly, it could be worth trying some alternative graphic devices such as cairo_pdf or svglite::svglite. The second option is to use the showtext package (Qiu and See file AUTHORS for details. 2021), which converts text into color-filled polygonal outlines for graphical vector formats.  Thirdly, the extrafont (Chang 2014) package allows embedding the fonts in the PDF file, which makes PDFs properly displayed on computers that do not have the given font. \n\n12.3.3 Fonts on maps\n\nBy default, tmap uses the \"sans\" font family with the \"plain\" font face (Figure 12.7). There are, however, three ways to customize the used fonts. The first one is to change all of the fonts and font faces for the whole map at once (Figure 12.8 (a)). This can be done with the text.fontfamily and text.fontface arguments of tm_layout().\n\ntm +\n    tm_layout(\n        text.fontface = \"italic\",\n        text.fontfamily = \"serif\"\n    )\n\nThe second way is to specify just some text elements independently (Figure 12.8 (b)). Many tmap functions, such as tm_text() or tm_credits(), have their own fontfamily and fontface arguments that can be adjusted. Additionally, tm_layout() allows to customize fonts for other map elements using prefixed arguments, such as, title.fontface or legend.title.fontfamily.\n\ntm +\n    tm_layout(\n        title.fontface = \"bold.italic\",\n        legend.title.fontfamily = \"monospace\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n(a) One font for all elements\n\n\n\n\n\n\n\n\n\n\n\n(b) Different fonts for different elements\n\n\n\n\n\n\nFigure 12.8: Examples of one font (font family and font face) used for all of the map elements (title, text labels, legend, and text annotation), and different fonts used for different map elements.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Map layout</span>"
    ]
  },
  {
    "objectID": "layout.html#sec-scale",
    "href": "layout.html#sec-scale",
    "title": "12  Map layout",
    "section": "\n12.4 Scale",
    "text": "12.4 Scale\nThe tmap package has a set of default sizes and widths for various map elements, such as the frame, text, borders, symbol sizes, and more. In the previous parts of this book, we modify some of these values for selected elements, such as the frame width or text size. At the same time, we can also change the size of all of the map elements at once – this is a role of the scale argument of the tm_layout() function.  \n\n\n\n\n\n\n\n\n\n(a) scale = 0.5\n\n\n\n\n\n\n\n\n\n(b) scale = 1.5\n\n\n\n\n\n\nFigure 12.9: Impact of the scale argument on the map layout.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Map layout</span>"
    ]
  },
  {
    "objectID": "layout.html#sec-design-mode",
    "href": "layout.html#sec-design-mode",
    "title": "12  Map layout",
    "section": "\n12.5 Design mode",
    "text": "12.5 Design mode\nMaps consist of various components, including the map content (with its frame), additional map elements (e.g., credits or a title), and the legend, which are often located in different places. They also have numerous margins – spaces between data and the frame, spaces between the frame and the plotting, spaces between the icons and the labels, etc.\nMany of these properties can be customized, however, it may be difficult to understand the effect of the changes.  To make it easier, tmap has a design mode that can be turned on by setting the tmap_design_mode() function to TRUE. When the design mode is turned on, the map is displayed in a special way: it shows all of the created map content, but also adds various lines and colored areas to the map. We may see an example of a map in the design mode in Figure 12.10:\n\n\nAdditionally, it returns a small table in the R console with sizes and an aspect ratio of the device, plot, facets, and map areas. \nThe design mode is useful to understand how the map is constructed and how the various arguments of the tm_layout() function impact the map layout.\n\n\ntmap_design_mode(TRUE)\n#&gt; design.mode: ON\ntm\n#&gt; ----------------W (in)--H (in)--asp---\n#&gt; | device        7.00 4.32 1.62 |\n#&gt; | plot area     6.35 4.15 1.53 |\n#&gt; | facets area   5.41 3.83 1.41 |\n#&gt; | map area      5.33 3.75 1.42 |\n#&gt; --------------------------------\n\n\n\n\n\n\nFigure 12.10\n\n\n\n\nThis mode is in place until the tmap_design_mode() function is set to FALSE. In the next few sections, we will show how the design mode can help us to understand the impact of various arguments of the tm_layout() function on the aspect ratio and margins of the map.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Map layout</span>"
    ]
  },
  {
    "objectID": "layout.html#sec-aspect",
    "href": "layout.html#sec-aspect",
    "title": "12  Map layout",
    "section": "\n12.6 Aspect ratio",
    "text": "12.6 Aspect ratio\n\nThe aspect ratio specifies the relation between the width and height of the map area of the plot. For statistical plots, aspect ratios usually adjust to the plotting space – thus, customization of an aspect ratio is usually not needed. For maps, this is not the case – we should not change the relation between the width and height of the data in a map as it has a specific projection that determines the spatial relation between the map features.\nBy default, the aspect ratio of the tmap is set to NA, which means that it is adjusted to the used shapes (Figure 12.1). \n\n\n\n\n\n\n\n\n\n(a) asp = 0\n\n\n\n\n\n\n\n\n\n(b) asp = 0.5\n\n\n\n\n\n\n\n\n\n\n\n(c) asp = 1\n\n\n\n\n\n\n\n\n\n(d) asp = 2\n\n\n\n\n\n\nFigure 12.11: Impact of the aspect ratio on the map layout.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Map layout</span>"
    ]
  },
  {
    "objectID": "layout.html#sec-lmargins",
    "href": "layout.html#sec-lmargins",
    "title": "12  Map layout",
    "section": "\n12.7 Margins",
    "text": "12.7 Margins\nMargins are spaces around the map content, which can be used to separate the map from other elements, such as the legend or the title or separate the map from the extent of the plotting area. They may serve various purposes, such as to make the map more readable, to avoid overlapping the map content with other elements, to create space for additional elements. On the other hand, making margins smaller can help to increase the map area or make the map more condensed.\nThere are several arguments in tm_layout() related to margins. All of the margin arguments can be customized either with a single value (which is then applied to all sides) or with a vector of four values, which represent the bottom, left, top, and right margins.   The most important margins arguments are inner.margins and outer.margins. \n\nThe inner margins are spaces between the map content (e.g., symbols, lines, polygons, raster) and the frame of the map (Figure 12.12). By default, the inner margins are set to c(0.02, 0.02, 0.02, 0.02), which means that there is a 2% margin on each side of the map content (Figure 12.1). An exception to this rule is raster maps, where the inner margins are set to c(0, 0, 0, 0) – meaning that there are no margins around the raster map content – by default. Increasing the inner margins can help to avoid overlapping of the map content with other elements, such as the legend or the title – for example, we could add some margin on the right side of the map and then place the legend there.  \n\n\n\n\n\n\n\n\n\n(a) No margins\n\n\n\n\n\n\n\n\n\n(b) c(0.8, 0.4, 0.2, 0)\n\n\n\n\n\n\nFigure 12.12: Impact of the inner.margins argument on the map layout.\n\n\n\nOuter margins are spaces between the map frame and the plotting area (Figure 12.13). By default, they are always set to c(0.02, 0.02, 0.02, 0.02), which means that there is a 2% margin outside of the map frame – giving a small “breathing space” around the map (Figure 12.1). We can increase it on a specific side, for example, to create more space for the legend or other map elements or we can remove it completely to, for example, arrange the map in a grid with other maps (Chapter 15) (Figure 12.13). \n\n\n\n\n\n\n\n\n\n(a) No margins\n\n\n\n\n\n\n\n\n\n(b) c(0.08, 0.04, 0.02, 0)\n\n\n\n\n\n\nFigure 12.13: Impact of the outer.margins argument on the map layout.\n\n\n\n\n\n\n\n\nNow, as we have seen how the design mode can help us to understand the impact of various arguments of the tm_layout() function, we can turn it off.\n\ntmap_design_mode(FALSE)\n#&gt; design.mode: OFF\n\n\n\n\n\nChang, Winston. 2014. Extrafont: Tools for Using Fonts. https://CRAN.R-project.org/package=extrafont.\n\n\nGuidero, Elaine. 2017. “Typography.” In Geographic Information Science & Technology Body of Knowledge, edited by John P. Wilson. Vol. 2017. University Consortium for Geographic Information Science (UCGIS).\n\n\nPedersen, Thomas Lin, Jeroen Ooms, and Devon Govett. 2021. Systemfonts: System Native Font Finding. https://CRAN.R-project.org/package=systemfonts.\n\n\nPedersen, Thomas Lin, and Maxim Shemanarev. 2021. Ragg: Graphic Devices Based on AGG. https://CRAN.R-project.org/package=ragg.\n\n\nPeng, Roger. 2016. Exploratory Data Analysis with R. United States: LeanPub.\n\n\nQiu, Yixuan, and authors/contributors of the included software. See file AUTHORS for details. 2021. Showtext: Using Fonts More Easily in r Graphs. https://CRAN.R-project.org/package=showtext.",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Map layout</span>"
    ]
  },
  {
    "objectID": "layout.html#footnotes",
    "href": "layout.html#footnotes",
    "title": "12  Map layout",
    "section": "",
    "text": "You can get the invalid font type error when saving the file.↩︎",
    "crumbs": [
      "Building blocks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Map layout</span>"
    ]
  },
  {
    "objectID": "map-projections.html",
    "href": "map-projections.html",
    "title": "13  Map projections (CRS)",
    "section": "",
    "text": "13.1 What are map projections?\nThis chapter focuses on the map projections. It gives a background on why do we need map projections and how to translate spatial data from an ellipsoid into a flat surface or computer screen. Then, it explains basic terms, gives an overview of map projections, and provides guidelines for choosing a suitable map projection for a specific application. Finally, it shows how to use R and the tmap package to specify and customize map projections.\nWe use maps so often in everyday life that most of us probably forget that a map is just a two-dimensional representation of a three-dimensional object, namely the Earth. For centuries, geographers and mathematicians wondered what the best way is to do this. Let us wonder with them for a second.\nThe world is depicted as an orange in Figure 13.1, not just to stimulate your appetite for this subject, but also because an orange peel serves as a good analogy for a two-dimensional map. A world map can be seen as an orange peel laid out on the table. The question is how to peel the orange and how to put the peel flat on the table.\nFigure 13.1: How to peel an orange?\nWhen we peel the orange, ideally, we want to rip the peel near areas of the Earth that are less interesting. What is interesting depends on the application – for applications where land mass is more important than water mass, it is a good idea to make the rips in the oceans. The (interrupted) Goode homolosine projection (Figure 13.2) embodies this idea. All continents and countries are preserved except Antarctica and Greenland. There is also a version of the Goode homolosine projection that focuses on preserving the oceans.\nFigure 13.2: The (interrupted) Goode homolosine projection\nTo make the analogy between the orange peel and the surface of the Earth complete, we have to assign two fictitious properties to the orange peel, namely that it is stretchable and deformable. These properties are needed in order to make a non-interrupted map, as we will see in the next sections.\nA method to flatten down the Earth, for which the Goode homolosine projection shown in Figure 13.2 is an example, is called a map projection. Technically, it is also known as a coordinate reference system (CRS), which specifies the corresponding coordinate system, as well as the transformations to other map projections.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Map projections (CRS)</span>"
    ]
  },
  {
    "objectID": "map-projections.html#sec-crs-earth",
    "href": "map-projections.html#sec-crs-earth",
    "title": "13  Map projections (CRS)",
    "section": "\n13.2 A model of the Earth",
    "text": "13.2 A model of the Earth\n The orange and the Earth have another thing in common: both are spheres, but not perfect ones. The Earth is metaphorically speaking a little fat: the circumference around the equator is 40,075 km, whereas around the circumference that crosses both poles is 40,009 km.  Therefore, the Earth can better be described as an ellipsoid. The same applies to an orange: every orange is a little different, but probably very few oranges are perfect spheres.\nAlthough the ellipsoid is a good mathematical model to describe the Earth’s surface, keep in mind that the surface of the Earth is not smooth – land mass usually lies at a higher altitude than sea level. We could potentially map each point on the surface of the Earth using a three-dimensional \\((x, y, z)\\) Cartesian coordinate system with the center of the mass of the Earth being the origin (0, 0, 0). However, since this has many mathematical complications, the ellipsoid is often sufficient as a model of the surface of the Earth.\n This ellipsoid model and its translation to the Earth’s surface is called a (geodetic) datum. The most popular datum is WGS84, which was introduced in 1984 as an international standard and was last revised in 2004. There are many (slightly) different datums, which are often tailored for local applications. For instance, NAD83, ETRS89, and GDA94 are slightly better models for North America, Europe, and Australia, respectively. However, since WGS84 is a very good approximation of the Earth as a whole, it has been widely adopted worldwide and is also used by the Global Positioning System (GPS).\n When we have specified a datum, we are able to specify geographic locations with two familiar variables, namely latitude and longitude. The latitude specifies the north-south position in degrees, where latitude = 0\\(^\\circ\\) is the equator. The latitudes for the north and south poles are 90\\(^\\circ\\) and \\(-90^\\circ\\), respectively. The longitude specifies the east-west position in degrees, where by convention, the longitude = 0\\(^\\circ\\) meridian crosses the Royal Observatory in Greenwich, UK. The Longitude range is -180\\(^\\circ\\) to 180\\(^\\circ\\), and since this is a full circle, -180\\(^\\circ\\) and \\(^\\circ\\) specify the exact longitude.\n When we see the Earth in its three-dimensional form, as in Figure 13.1, the latitude parallels are the horizontal lines around the Earth, and the longitude meridians are the vertical lines around the Earth. The set of longitude meridians and latitude parallels is also referred to as graticule. In all the figures in this section, latitude parallels are shown as gray lines for \\(-60^\\circ\\), \\(-30^\\circ\\), \\(0^\\circ\\), \\(30^\\circ\\) and \\(60^\\circ\\), and longitude meridians from \\(-180^\\circ\\) to \\(180^\\circ\\) at every \\(30^\\circ\\).\nPlease keep in mind that only a latitude and longitude are not sufficient to specify a geographic location. A datum is required. When people exchange latitude-longitude data, it is safe to assume that they implicitly have used the WGS84 datum. However, it is good practice to specify the datum explicitly.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Map projections (CRS)</span>"
    ]
  },
  {
    "objectID": "map-projections.html#sec-crs-projections",
    "href": "map-projections.html#sec-crs-projections",
    "title": "13  Map projections (CRS)",
    "section": "\n13.3 Platte Carrée and Web Mercator",
    "text": "13.3 Platte Carrée and Web Mercator\n Let’s take a closer look at two widely used map projections, namely the plain latitude-longitude coordinate system (using the WGS84 datum) and the Web Mercator projection, which is currently the de facto standard for interactive maps. These projections are indexed as EPSG:4326 and EPSG:3857 respectively. EPSG is a database of standard map projections.\n\n\n\n\n\n\n\n\nFigure 13.3: Latitude longitude coordinates (EPSG:4326)\n\n\n\n\nWhen we fictitiously make little holes in the orange peel at both poles, and stretch these open so wide that they have the same width as the equator, we obtain the cylinder depicted in Figure 13.3 (left). Note that the longitude lines have become straight vertical lines. When we unroll this cylinder, we obtain a map where the \\(x\\) and \\(y\\) coordinates are the longitude and latitude, respectively. This CRS, which is known as EPSG:4326, is shown in Figure Figure 13.3 (right).\n EPSG:4326 is an unprojected CRS since the longitude and latitude have not been transformed. With projected CRSs, the \\(x\\) and \\(y\\) coordinates refer to specific measurement units, usually meters. The projected variant of this CRS is called the Platte Carrée (EPSG:4087), and is exactly the same map as shown in Figure Figure 13.3 (right), but with other \\(x\\) and \\(y\\) value ranges. \nObserve since we stretched the poles open, the area near the poles has been stretched out as well. More specifically, the closer the land is to one of the poles, the more it has been stretched out. Since the stretching direction is only horizontal, the shapes of the areas have become wider. A good example is Greenland, which is normally a ‘tall’ area (as can be seen in Figure 13.1).\n  In order to fix these deformed areas, Gerardus Mercator, a Flemish geographer in the 16th century, introduced a method to compensate for this by inflating the areas near the poles even more, but now only in a vertical direction. This projection is called the Mercator projection. For web applications, this projection has been slightly modified and renamed to the Web Mercator projection (EPSG:3857). The cylinder and plain map that uses this projection are shown in Figure 13.4.\n\n\n\n\n\n\n\nFigure 13.4: Web Mercator projection (EPSG:3857)\n\n\n\n\nAlthough the areas near the poles have been inflated quite a lot, especially Antarctica and Greenland, the shape of the areas is more or less correct, in particular regarding small areas (which can be seen by comparing with Figure 13.1). The Mercator projection is very useful for navigational purposes, and has therefore been embraced by sailors ever since. Also today, the Web Mercator is the de facto standard for interactive maps and navigation services. However, for maps that show data, the (Web) Mercator projection should be used with great caution because the hugely inflated areas will influence how we perceive spatial data. We will discuss this in the next section.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Map projections (CRS)</span>"
    ]
  },
  {
    "objectID": "map-projections.html#sec-proj-types",
    "href": "map-projections.html#sec-proj-types",
    "title": "13  Map projections (CRS)",
    "section": "\n13.4 Types of map projections",
    "text": "13.4 Types of map projections\n\n Let us return to the original question: how can we create a two-dimensional representation of our three-dimensional Earth? Although there are many ways, four basic map projection types can be distinguished. These are depicted in Figure 13.5.\n\n\n\n\n\n\n\nFigure 13.5: Four types of map projections\n\n\n\n\n Examples of cylindrical projections have already been given in the previous section: both Platte Carrée and Web Mercator are cylindrical. Another widely used cylindrical map projection is the Universal Transverse Mercator (UTM). Its cylinder is not placed upright but horizontally. There are 60 positions in which this cylinder can be placed, where in each position, the cylinder faces a longitude range of 6 degrees. In other words, the UTM is not a single projection, but a series of 60 projections.\nThere are many projections that are pseudo-cylinders in the sense that the radius around the poles is smaller than around the equator. An example is the Robinson projection shown in Figure 13.6. Almost all commonly used standard World map projections are (pseudo-)cylindrical. \n\n\n\n\n\n\n\nFigure 13.6: The Robinson projection, which is pseudo-cylindrical.\n\n\n\n\n An example of a conic map projection is shown in Figure 13.7 (a). As a result of unfolding a cone on a flat surface, a gap is created. The size (angle) of this gap depends on the width of the cone. There are also pseudo-conic map projections in which some meridians (longitude lines) are curved. Conic map projections are useful for mid-latitude areas where the Earth’s surface and the cone are nearly parallel to each other.\n Planar map projections, also known as azimuthal projections, project the Earth on a disk. This can be done in several ways. One effective method is to use the position of an imaginary light source. The light source can be positioned in three different ways: inside the globe, at the surface of the globe opposite the disk, or at an infinite distance from the disk. The corresponding families of projections are called gnomonic, stereographic, and orthogonal projections.\nPlanar map projections are often used for a specific country or continent. An example is the Lambert Azimuthal Equal-Area projection (EPSG:3035), shown in Figure 13.7 (b), which is optimized for Europe. It can be classified as a stereographic projection, although the light beams are not straight but curved. Another example of a planar map projection is the orange shown in Figure 13.1. This is an orthogonal projection.\n\n\n\n\n\n\n\n\n\n(a) World Equidistant Conic projection\n\n\n\n\n\n\n\n\n\n(b) Lambert Azimuthal Equal-Area projection\n\n\n\n\n\n\nFigure 13.7: Examples of a conic and a planar projection.\n\n\n The (interrupted) Goode homolosine projection shown in Figure 13.2 is an example of an interrupted projection. A special class of these projections are polyhedral projections, which consists of planar faces. In Figure 13.5 a polyhedral of six faces is illustrated. There is no limit of the number of faces, as the myriahedral projections  illustrate.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Map projections (CRS)</span>"
    ]
  },
  {
    "objectID": "map-projections.html#sec-crs-choose",
    "href": "map-projections.html#sec-crs-choose",
    "title": "13  Map projections (CRS)",
    "section": "\n13.5 Which projection to choose?",
    "text": "13.5 Which projection to choose?\n Hopefully, it is clear that there is no perfect projection, as each has its pros and cons. Whether a projection is suitable for a certain application depends on two factors. The first factor is the type of application and, in particular, which map projection properties are useful or even required for that application (Section 13.5.1). For instance, navigation requires other map projection properties than statistical maps. The second factor is the area of interest (Section 13.5.2). Is the whole World visualized or only a part, and in the latter case, which part? In this section, guidelines are provided to help you choose a suitable projection based on these two aspects.\nBefore we delve deeper into selecting a projection, it is worth noting that for many countries and continents, government agencies have already chosen projections to be the standard for mapping spatial data. For instance, a standard for Europe, used by Eurostat (the statistical agency of the European Union), is the Lambert Azimuthal Equal-Area projection, shown in Figure 13.7 (b). If the area of interest has such a standard, it is recommended to use it, because it can be safely assumed that this standard is a proper projection, and moreover, it makes cooperation and communication with other parties easier. However, be aware of the limitations that this particular projection may have, and that there may be better alternatives out there.\n\n13.5.1 Map projection properties\n The type of application is important for the choice of a map projection. However, it would be quite tedious to list all possible applications and provide projection recommendations for each of them. Instead, we focus on four map projection properties. The key step is to find out which of these properties are useful or even required for the target application. The four properties are listed in Table 13.1.\n\n\n\nTable 13.1: Map projection properties\n\n\n\n\n    \n\n      \n\n\n\nProperty\n                  Conformal\n                  Equal area\n                  Equidistant\n                  Azimuthal\n                \n\nPreserves\n                  Local angle (shape)\n                  Area\n                  Distance\n                  Direction\n                \n\nApplications\n                  Navigation, climate\n                  Statistics\n                  Geology\n                  Geology\n                \n\nExamples (cyclindrical)\n                  Mercator\n                  Gall-Peters, Eckert IV\n                  Equirectangular\n                  none\n                \n\nExamples (conic)\n                  Lambert conformal conic\n                  Albers conic\n                  Equidistant conic\n                  none\n                \n\nExamples (planar)\n                  Stereographic\n                  Lambert azimuthal equal-area\n                  Azimuthal equidistant\n                  Stereographic, Lambert azimuthal equal-area\n                \n\nExamples (interrupted)\n                  Myriahedral\n                  Goode homolosine, Myriahedral\n                  none\n                  none\n                \n\n\n\n\n\n\n\n\n\n A conformal projection means that local angles are preserved. In practice, that means, for instance, that a map of a crossroad preserves the angles between the roads. Therefore, this property is required for navigational purposes. As a consequence, local angles are preserved, and local shapes are also preserved. That means that a small island will be drawn on a map in its true shape, as seen from the sky perpendicular above it. The Web Mercator, as shown in Figure 13.4, satisfies this property. The closer an area is to one of the poles, the more it is enlarged, but since this is done in both dimensions (latitude and longitude), local shapes are preserved.\n A map projection is called equal-area if the areas are proportional to the true areas. This is strongly recommended for maps that display statistics to prevent perceptual bias. Figure 13.8 shows two World maps of population density per country, one in the Web Mercator projection and the other in Eckert IV projection. The perception of World population is different in these maps; in (a) the vast lands in low-populated areas seem to be Canada, Greenland, and Russia, whereas in (b) also North Africa and Australia emerge as vast low-populated areas.\n\n\n\n\n\n\n\n\n\n\n(a) Web Mercator is not equal-area\n\n\n\n\n\n\n\n\n\n\n\n(b) Eckert IV is equal-area\n\n\n\n\n\n\nFigure 13.8: Comparison of Web Mercator and Eckert IV projections.\n\n\n\n The other two map projection properties are related to one central point on the map. A map projection is called equidistant if the distances to any other point in the map are preserved and azimuthal if the directions to any other point are preserved. These properties are, in particular, useful in the field of geology. One example is a seismic map around the epicenter of a recent earthquake, where it is crucial to show how far and in which direction the vibrations are spreading.\n A map projection can satisfy at most two of these properties. Many map projections do not satisfy any property but are intended as a compromise. An example is the Robinson projection, shown in Figure 13.6. \n\n13.5.2 Area of interest\n The next aspect that is important for the choice of a map projection is the area of interest. In general, the larger the area, the more concessions have to be made, since the larger the area, the more difficult it is to make a two-dimensional projection.\nThe following Table 13.2 provides recommendations for map projection types based on the area size and latitude of the area.\n\n\n\nTable 13.2: Recommended projections for different areas.\n\n\n\n\n    \n\n      \n\nView\n                Low latitude (equator)\n                Mid latitude\n                High latitude (poles)\n              \n\n\nWorld\n                  Pseudo-cylindrical\n                  Pseudo-cylindrical\n                  Pseudo-cylindrical\n                \n\nHemisphere\n                  Azimuthal\n                  Azimuthal\n                  Azimuthal\n                \n\nContinent or smaller\n                  Cylindrical or azimuthal\n                  Conic or azimuthal\n                  Azimuthal\n                \n\n\n\n\n\n\n\n\n\nFor World maps, pseudo-cylindrical map projections, such as the Robinson projection (Figure 13.6) and the Eckert IV projection (Figure 13.8 (b)) are very popular because they have less distortion than other map projections. For areas that cover half of the sphere, i.e., a hemisphere, azimuthal map projections are recommended. Four hemispheres are often used: the Northern and Southern Hemispheres, with the North and South Poles as their centers, the Western Hemisphere consisting of the Americas, and the Eastern Hemisphere, which includes the other continents. However, other hemispheres are often used implicitly, such as a hemisphere centered on Europe used in the Lambert Azimuthal Equal-Area projection shown in Figure 13.7 (b).\nFor areas with the size of a continent or country, the azimuthal map projection type can be used when centered on the area of interest. In particular, the Lambert Azimuthal Equal-Area projection when the equal area is required and the Azimuthal Equidistant projection when preserving distances is essential. Alternatively, cylindrical and conic map projection types can be used for areas at low and mid-latitudes, respectively. Another alternative is to use a UTM projection. However, this is only recommended when the target area spans less than 6 degrees longitude and does not cross the UTM zone lines.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Map projections (CRS)</span>"
    ]
  },
  {
    "objectID": "map-projections.html#sec-crs-in-r",
    "href": "map-projections.html#sec-crs-in-r",
    "title": "13  Map projections (CRS)",
    "section": "\n13.6 CRS in R",
    "text": "13.6 CRS in R\n Coordinate Reference Systems (CRSs) are implemented in the software library PROJ. With implementation, we mean specifying a CRS and transforming coordinates from one CRS to another. PROJ is used by every popular software application for spatial data, in particular, ArcGIS, QGIS, and GRASS GIS, and also by many programming languages, including R. The sf and terra packages integrate the PROJ capabilities into R.\nA CRS is represented in sf by an object of class crs, which can be retrieved or set with the function st_crs(). In the following example, a crs object is created from an EPSG code, in this case, 3035, the Lambert Azimuthal Equal-Area projection for Europe.\n\nlibrary(sf)\n# CRS Lambert Azimuthal Equal-Area projection\nst_crs(\"EPSG:3035\")\n#&gt; Coordinate Reference System:\n#&gt;   User input: EPSG:3035 \n#&gt;   wkt:\n#&gt; PROJCRS[\"ETRS89-extended / LAEA Europe\",\n#&gt;     BASEGEOGCRS[\"ETRS89\",\n#&gt;         ENSEMBLE[\"European Terrestrial Reference System 1989 ensemble\",\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 1989\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 1990\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 1991\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 1992\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 1993\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 1994\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 1996\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 1997\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 2000\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 2005\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 2014\"],\n#&gt;             MEMBER[\"European Terrestrial Reference Frame 2020\"],\n#&gt;             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#&gt;                 LENGTHUNIT[\"metre\",1]],\n#&gt;             ENSEMBLEACCURACY[0.1]],\n#&gt;         PRIMEM[\"Greenwich\",0,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;         ID[\"EPSG\",4258]],\n#&gt;     CONVERSION[\"Europe Equal Area 2001\",\n#&gt;         METHOD[\"Lambert Azimuthal Equal Area\",\n#&gt;             ID[\"EPSG\",9820]],\n#&gt;         PARAMETER[\"Latitude of natural origin\",52,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8801]],\n#&gt;         PARAMETER[\"Longitude of natural origin\",10,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8802]],\n#&gt;         PARAMETER[\"False easting\",4321000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8806]],\n#&gt;         PARAMETER[\"False northing\",3210000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8807]]],\n#&gt;     CS[Cartesian,2],\n#&gt;         AXIS[\"northing (Y)\",north,\n#&gt;             ORDER[1],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;         AXIS[\"easting (X)\",east,\n#&gt;             ORDER[2],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;     USAGE[\n#&gt;         SCOPE[\"Statistical analysis.\"],\n#&gt;         AREA[\"Europe - European Union (EU) countries and candidates. Europe - onshore and offshore: Albania; Andorra; Austria; Belgium; Bosnia and Herzegovina; Bulgaria; Croatia; Cyprus; Czechia; Denmark; Estonia; Faroe Islands; Finland; France; Germany; Gibraltar; Greece; Hungary; Iceland; Ireland; Italy; Kosovo; Latvia; Liechtenstein; Lithuania; Luxembourg; Malta; Monaco; Montenegro; Netherlands; North Macedonia; Norway including Svalbard and Jan Mayen; Poland; Portugal including Madeira and Azores; Romania; San Marino; Serbia; Slovakia; Slovenia; Spain including Canary Islands; Sweden; Switzerland; Türkiye (Turkey); United Kingdom (UK) including Channel Islands and Isle of Man; Vatican City State.\"],\n#&gt;         BBOX[24.6,-35.58,84.73,44.83]],\n#&gt;     ID[\"EPSG\",3035]]\n\n A crs object contains Well Known Text (WKT). It includes a specification of the used datum as well as information how to transform it into other CRSs. Understanding the exact content of the WTK is not important for most users, since it is not needed to write a WKT yourself.\n A crs object can be created in several ways: \n\nThe first is with an EPSG number as user input specification as shown above. \n\nThe second is also with a user input specification, but with a so-called proj4 character string. The proj4 character string for the LAEA projection is \"+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs\". However, proj4 character strings should be used with caution since they often lack important CRS information regarding datums and CRS transformations. Also note that the name proj4 stands for the PROJ library version 4, while the current major version of PROJ at the time of writing is already 9. \n\nThe third way is to provide some WKT definition of the projection. \n\nThe last way to create a crs object is to extract it from an existing spatial data object (e.g., an sf, terra, or stars object) using the st_crs() function.\n\nA crs object can define a new spatial object’s projection or transform an existing spatial object into another projection. In the example below, we created a new object, waterfalls, with names and coordinates of three famous waterfalls. Next, we converted it into a spatial object of the sf class, waterfalls_sf() with st_as_sf(). We can see that our object’s coordinate reference system is not defined with the st_crs() function.\n\n# create a data.frame of three famous waterfalls\nwaterfalls = data.frame(name = c(\"Iguazu Falls\", \"Niagara Falls\", \"Victoria Falls\"), \n                        lat = c(-25.686785, 43.092461, -17.931805), \n                        lon = c(-54.444981, -79.047150, 25.825558))\n# create sf object (without specifying the crs)\nwaterfalls_sf = st_as_sf(waterfalls, coords = c(\"lon\", \"lat\"))\n# extract crs (not defined yet)\nst_crs(waterfalls_sf)\n#&gt; Coordinate Reference System: NA\n\nThis function also allows us to specify CRS of our object – in this example, coordinates of our object are in the WGS84 coordinate system, and thus we can use the EPSG code of 4326. We can also confirmed that our operation was successful also using st_crs().\n\n# specify crs\nst_crs(waterfalls_sf) = \"EPSG:4326\"\n# extract crs\nst_crs(waterfalls_sf)\n#&gt; Coordinate Reference System:\n#&gt;   User input: EPSG:4326 \n#&gt;   wkt:\n#&gt; GEOGCRS[\"WGS 84\",\n#&gt;     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n#&gt;         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n#&gt;         MEMBER[\"World Geodetic System 1984 (G730)\"],\n#&gt;         MEMBER[\"World Geodetic System 1984 (G873)\"],\n#&gt;         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n#&gt;         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n#&gt;         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n#&gt;         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n#&gt;         MEMBER[\"World Geodetic System 1984 (G2296)\"],\n#&gt;         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;         ENSEMBLEACCURACY[2.0]],\n#&gt;     PRIMEM[\"Greenwich\",0,\n#&gt;         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;     CS[ellipsoidal,2],\n#&gt;         AXIS[\"geodetic latitude (Lat)\",north,\n#&gt;             ORDER[1],\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;         AXIS[\"geodetic longitude (Lon)\",east,\n#&gt;             ORDER[2],\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;     USAGE[\n#&gt;         SCOPE[\"Horizontal component of 3D system.\"],\n#&gt;         AREA[\"World.\"],\n#&gt;         BBOX[-90,-180,90,180]],\n#&gt;     ID[\"EPSG\",4326]]\n\nAlternatively, it is possible to set the CRS when creating a new sf object, as you can see below.\n\nwaterfalls_sf = st_as_sf(waterfalls, \n                         coords = c(\"lon\", \"lat\"), crs = \"EPSG:4326\")\n\nThe st_transform() function is used to convert the existing vector spatial object’s coordinates into another projection. For example, let’s transform our waterfalls_sf object to the Equal Earth projection (EPSG:8857).\n\nwaterfalls_sf_trans = st_transform(waterfalls_sf, \"EPSG:8857\")\nwaterfalls_sf_trans\n#&gt; Simple feature collection with 3 features and 1 field\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -6580000 ymin: -3240000 xmax: 2420000 ymax: 5260000\n#&gt; Projected CRS: WGS 84 / Equal Earth Greenwich\n#&gt;             name                  geometry\n#&gt; 1   Iguazu Falls POINT (-4969711 -3244138)\n#&gt; 2  Niagara Falls  POINT (-6583123 5261565)\n#&gt; 3 Victoria Falls  POINT (2416945 -2285044)\n\nFigure 13.9 shows the example data in the WGS84 coordinate system on the top and in the Equal Earth projection on the bottom. You can see here that the decision of the projection used has an impact not only on the coordinates (notice the grid values), but also the continents’ shapes.\n\n\n\n\n\n\n\n\n\n\n(a) WGS84 coordinate system\n\n\n\n\n\n\n\n\n\n\n\n(b) Equal Earth projection\n\n\n\n\n\n\nFigure 13.9: Comparison between the same dataset of three waterfalls",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Map projections (CRS)</span>"
    ]
  },
  {
    "objectID": "map-projections.html#specifying-map-projections-within-tmap",
    "href": "map-projections.html#specifying-map-projections-within-tmap",
    "title": "13  Map projections (CRS)",
    "section": "\n13.7 Specifying map projections within tmap\n",
    "text": "13.7 Specifying map projections within tmap\n\n\nNow that the concepts of map projections are established, we can examine how to specify map projections in tmap. We will expand on the short introduction from Section 5.4 and show how to use various tools available in the tm_crs() function.\n\n13.7.1 Vector data\nFirst, see how to specify a map projection for vector data. We will use the worldvector.gpkg and worldcities.gpkg datasets – the first one uses the Equal Earth projection (EPSG:8857), and the second one uses the WGS 84 coordinate system (EPSG:4326). Additionally, to show the effect of map projections, we will transform the worldvector data into the WGS 84 coordinate system, namely worldvector_wgs84.\n\nlibrary(tmap)\nlibrary(sf)\nworldvector = read_sf(\"data/worldvector.gpkg\")\nworldcities = read_sf(\"data/worldcities.gpkg\")\nworldvector_wgs84 = st_transform(worldvector, \"EPSG:4326\")\n\nFigure 13.10 (a) shows the map of the world in the WGS 84 coordinate system created with the code below. We often see this coordinate system used in various global maps. However, as discussed earlier in this chapter, it is not the best choice for visualizing the whole World – WGS 84 is an unprojected coordinate system, and thus it has a lot of distortions, especially going further from the equator.\n\ntm = tm_shape(worldvector_wgs84) +\n  tm_polygons() +\n  tm_shape(worldcities) +\n  tm_dots() +\n  tm_text(\"name\")\ntm\n\nWe can improve this map by changing the projection to a more suitable one, such as Equal Earth, directly in the map creation code (Figure 13.10 (b)). We just need to add the tm_crs() function with the desired projection, e.g., tm_crs(\"+proj=eqearth\").\n\ntm +\n  tm_crs(\"+proj=eqearth\") # or \"EPSG:8857\"\n\n\n\n\n\n\n\n\n\n\n(a) WGS 84 (EPSG:4326)\n\n\n\n\n\n\n\n\n\n(b) Equal Earth projection (EPSG:8857)\n\n\n\n\n\n\nFigure 13.10: Map projections examples.\n\n\nThe tm_crs() function is actually a small toolbox helping to manage map projections. As you have seen above, if we know the projection’s name (\"+proj=eqearth\") or code (\"EPSG:8857\") we can specify it directly. You can also use the tm_crs() function if you do not know the projection’s name or code – it accepts the \"auto\" argument. It will automatically select a suitable projection based on the data’s extent and the map’s properties. For example, if the map is global, it will select the pseudocylindrical projection Equal Earth (Figure 13.11).\n\ntm + \n  tm_crs(\"auto\")\n\n\n\n\n\n\nFigure 13.11: Map with data projected into the automatically selected projection.\n\n\n\n\nWith the tm_crs() function set to \"auto\", we may also specify the map projection property, such as \"area\", \"distance\", or \"shape\". The \"area\" property (equal area) uses the Lambert Azimuthal Equal Area projection, \"distance\" (equidistant) uses the Azimuthal Equidistant projection, and \"shape\" (conformal) uses the Stereographic projection. Figure 13.12 displays the map with the \"distance\" property – this means that our data is projected into the Azimuthal Equidistant projection, in this case, with the center on the coordinates of zero latitude and zero longitude. Then, every point on the map is equidistant from that center.\n\ntm_shape(worldvector_wgs84) +\n  tm_polygons() +\n  tm_shape(worldcities) +\n  tm_dots() +\n  tm_text(\"name\") +\n  tm_crs(\"auto\", property = \"distance\")\n\n\n\n\n\n\nFigure 13.12: Map with data projected into the automatically selected projection with distance property.\n\n\n\n\n\n13.7.2 Raster data\nThe above features of the tm_crs() function also apply to raster data. However, at the same time, reprojecting raster data is more complex than reprojecting vector data. Reprojections of vector data are usually straightforward because each spatial coordinate is reprojected individually.  Reprojecting of raster data, on the other hand, is more complex and requires using one of two approaches. The first approach applies raster warping, which is a name for two separate spatial operations: the creation of a new regular raster object and the computation of new pixel values through resampling (for more details, read Chapter 7 of Lovelace, Nowosad, and Muenchow (2025)). This is the default option in tmap, however, it has some limitations and it is not always possible to use it. The second approach involves transforming the coordinates of the raster cells, resulting in a curvilinear grid. Let’s see how to use these two approaches in tmap based on the worldelevation.tif raster data.\n\nlibrary(stars)\nworldelevation = read_stars(\"data/worldelevation.tif\")\n\nFigure 13.13 (a) shows the World elevation raster reprojected to Equal Earth. Some of you can quickly notice that certain areas, such as parts of Antarctica, New Zealand, Alaska, and the Kamchatka Peninsula, are presented twice, with one version being largely distorted. Another limitation of raster.warp = TRUE is the use of the nearest neighbor resampling only – while it can be a proper method to use for categorical rasters, it can have some unintended consequences for continuous rasters (such as the \"worldelevation.tif\" data).\n\ntm_shape(worldelevation) +\n  tm_raster(col.scale = tm_scale(values = terrain.colors(8))) +\n  tm_crs(\"+proj=eqearth\") # or \"EPSG:8857\"\n\nThe second approach (tm_options(raster.warp = FALSE)) computes new coordinates for each raster cell, keeping all of the original values and results in a curvilinear grid. This calculation could deform the shapes of original grid cells, and usually curvilinear grids take a longer time to plot1.\nFigure 13.13 (b) illustrates an example of the second approach, which yielded a better result in this case without any spurious land. However, the creation of the (b) map takes about ten times longer than the (a) map.\n\ntm_shape(worldelevation) +\n  tm_raster(col.scale = tm_scale(values = terrain.colors(8))) +\n  tm_crs(\"+proj=eqearth\") +\n  tm_options(raster.warp = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n(a) created using raster.warp = TRUE\n\n\n\n\n\n\n\n\n\n\n\n(b) created using raster.warp = FALSE\n\n\n\n\n\n\nFigure 13.13: Two elevation maps in the Equal Earth projection",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Map projections (CRS)</span>"
    ]
  },
  {
    "objectID": "map-projections.html#customizing-maps-for-global-projections",
    "href": "map-projections.html#customizing-maps-for-global-projections",
    "title": "13  Map projections (CRS)",
    "section": "\n13.8 Customizing maps for global projections",
    "text": "13.8 Customizing maps for global projections\nThe tmap package also offers several additional features that can be used to customize maps with global projections. For instance, the tm_layout() function has an argument earth_boundary that can be set to TRUE to add a boundary around the Earth. Then, we can also set the bg.color argument to specify the background color of the map, which will only apply to the area inside the Earth boundary for a given projection (Figure 13.14). \n\ntm +\n  tm_crs(\"+proj=eqearth\") +\n  tm_layout(earth_boundary = TRUE,\n            bg.color = \"lightblue\")\n\n\n\n\n\n\nFigure 13.14: Map with data projected into Equal Earth and with a customized style.\n\n\n\n\nThese features can be used to create more visually appealing maps. They are available to a large set of projections2, some of which are shown in Figure 13.15. You may notice that these projections have not only different visual styles but also different shapes of the Earth boundary and focus on preserving different map projection properties.\n\n\n\n\n\n\n\nFigure 13.15: Examples of map projections for the whole world.\n\n\n\n\n\nOne particular projection that is worth mentioning is the orthographic projection. It is a planar projection that represents the Earth as if it were viewed from space, with the center of the projection at a specific latitude and longitude. We can use the tm_crs() function to apply the orthographic projection with the +proj=ortho argument, and then set the lat_0 and lon_0 parameters to specify the center of the projection. Figure 13.16 shows two examples of the orthographic projection centered on different coordinates: the first one is centered on 30\\(^\\circ\\)N, 0\\(^\\circ\\)E, and the second one is centered on 0\\(^\\circ\\)N/S, 100\\(^\\circ\\)E.\ntm +\n  tm_graticules(labels.show = FALSE) +\n  tm_crs(\"+proj=ortho +lat_0=30 +lon_0=0\", bbox = \"FULL\")+\n  tm_layout(bg.color = \"lightblue\",\n            earth_boundary = TRUE,\n            frame = FALSE)\ntm +\n  tm_graticules(labels.show = FALSE) +\n  tm_crs(\"+proj=ortho +lat_0=0 +lon_0=100\", bbox = \"FULL\")+\n  tm_layout(bg.color = \"lightblue\",\n            earth_boundary = TRUE,\n            frame = FALSE)\n\n\n\n\n\n\n\n\n\n(a) Centered on 30°N, 0°E\n\n\n\n\n\n\n\n\n\n(b) Centered on 0°N/S, 100°E\n\n\n\n\n\n\nFigure 13.16: Orthographic projection examples.\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote, that in these examples, the bbox argument is set to \"FULL\", which means that the whole Earth is displayed – it is useful when the extent of the data is smaller than the whole Earth.\n\n\n\n\n\n\n\n\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2025. Geocomputation with R. Second. CRC Press.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Map projections (CRS)</span>"
    ]
  },
  {
    "objectID": "map-projections.html#footnotes",
    "href": "map-projections.html#footnotes",
    "title": "13  Map projections (CRS)",
    "section": "",
    "text": "For more details of the first approach, see ?stars::st_warp() and of the second approach, see ?stars::st_transform().↩︎\nFind more projections in the PROJ documentation at https://proj.org/en/stable/operations/projections↩︎",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Map projections (CRS)</span>"
    ]
  },
  {
    "objectID": "charts.html",
    "href": "charts.html",
    "title": "14  Charts",
    "section": "",
    "text": "14.1 Numerical data\nThematic maps usually represent one or more variables using colors, shapes, or sizes. Then, the map legend is used to explain the meaning of these visual variables (Section 9.1). Such a legend can be expanded (or even replaced, Section 14.4) with a chart that provides more information about the distribution of the variable values.\nThe tmap package provides several chart types that can be used in the map legend (Table 14.1). They are specified in one of the *.chart arguments of a layer function, e.g., fill.chart of tm_polygons(), size.chart of tm_dots(), etc. The use of a chart type depends on the type of data we want to represent, i.e., whether it is numerical or categorical, and whether it is univariate or bivariate.\nFor the examples in this chapter, we will use the Slovenian regions dataset that contains information about the population density, region group, and the percentage of the population aged 65 or more in each region.\nThe first group of charts is used for numerical data, i.e., data that can take any value within a range. It includes histograms, box plots, violin plots, and donut charts.\nHistograms are the most common chart type used to represent the distribution of a numerical variable. They show how often each range of values occurs in the data – helping to understand which values are more common and if there are any outliers. To add a histogram to the map, we use the tm_chart_histogram() function in the fill.chart argument of the tm_polygons() function (Figure 14.1 (a)).\ntm_shape(slo_regions) +\n  tm_symbols(fill = \"pop_dens\",\n             fill.chart = tm_chart_histogram())\nSuch a histogram, like other charts, is automatically placed along the map legend. However, we can position them independently of the map legend using the position argument of the tm_chart_*() and tm_legend() functions (Figure 14.1 (b)).\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.chart = tm_chart_histogram(\n                position = tm_pos_out(\"left\", \"center\")\n                ),\n              fill.legend = tm_legend(\n                position = tm_pos_out(\"right\", \"center\")\n                )\n              )\n(a) Default histogram\n\n\n\n\n\n\n\n\n\n\n\n(b) Repositioned histogram\n\n\n\n\n\n\nFigure 14.1: Histogram added to a map to represent the distribution of a variable.\nFigure 14.2 shows additional three chart types that can be used for numerical data: box plots, violin plots, and donut charts. They can be added to the map using the tm_chart_box(), tm_chart_violin(), and tm_chart_donut() functions, respectively. As you may notice, these charts show similar messages, e.g., than the middle value range is the most common. On the other hand, box plots directly show the median and quartiles of the data, violin plots also show the density of the data distribution, and donut charts show the proportions of the data. They also have different aesthetics. Thus, the choice of the chart type depends on the message we want to convey and the aesthetics we prefer.\n# box plot\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.chart = tm_chart_box())\n# violin plot\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.chart = tm_chart_violin())\n# donut plot\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.chart = tm_chart_donut())\nFigure 14.2: Charts for numerical data.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Charts</span>"
    ]
  },
  {
    "objectID": "charts.html#categorical-data",
    "href": "charts.html#categorical-data",
    "title": "14  Charts",
    "section": "\n14.2 Categorical data",
    "text": "14.2 Categorical data\nThe second group of charts is used for categorical data – which can take only a limited number of values. It includes bar charts (tm_chart_donut()) and donut charts (tm_chart_bar()): bar charts show the frequency of each category, while donut charts show the proportions of each category (Figure 14.3). In the examples below, we represent the region groups of each region in Slovenia and observe that there are more regions in the “Central” and “West” groups than in the others.\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"region_group\",\n              fill.chart = tm_chart_donut())\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"region_group\",\n              fill.chart = tm_chart_bar())\n\n\n\n\n\n\n\n\nFigure 14.3: Charts for categorical data.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Charts</span>"
    ]
  },
  {
    "objectID": "charts.html#bivariate-data",
    "href": "charts.html#bivariate-data",
    "title": "14  Charts",
    "section": "\n14.3 Bivariate data",
    "text": "14.3 Bivariate data\nThe third group of charts is used for bivariate data, i.e., data that contains two variables. It includes a heatmap chart (tm_chart_heatmap()) that shows how often each combination of values occurs in the data (Figure 14.4). \n\ntm_shape(slo_regions) +\n  tm_polygons(fill = tm_vars(c(\"pop_dens\", \"pop65perc\"), multivariate = TRUE),\n              fill.scale = tm_scale_bivariate(values = \"purplegold\"),\n              fill.chart = tm_chart_heatmap())\n\n\n\n\n\n\nFigure 14.4: Bivariate charts used in case of representing a relationship between two numerical variables.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Charts</span>"
    ]
  },
  {
    "objectID": "charts.html#sec-charts-customization",
    "href": "charts.html#sec-charts-customization",
    "title": "14  Charts",
    "section": "\n14.4 Additional chart customization",
    "text": "14.4 Additional chart customization\nAll of the charts are directly based on the visual variables from the map layer and then created using the ggplot2 package. By default, however, the charts are much simplified, not showing all the details that ggplot2 can provide, such as axis labels, titles, and various theme elements.  \nAt the same time, we may want to customize the charts to fit our map design better or to add more information. This can be done with additional arguments of the tm_chart_*() functions, such as plot.axis.x, plot.axis.y, and extra.ggplot2. The first two are logical arguments that control whether the x and y axes are shown in the chart, respectively. The last one, extra.ggplot2, is a list of additional ggplot2 functions that are applied to the chart – for example, we may want to change the aesthetics of the chart, such as the background color as shown in Figure 14.5.\n\nlibrary(ggplot2)\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.chart = tm_chart_histogram(\n                plot.axis.x = FALSE,\n                extra.ggplot2 = list(\n                  theme(plot.background = element_rect(fill = \"lightgray\"))\n                )\n              ))\n\n\n\n\n\n\nFigure 14.5: Customizing charts with ggplot2.\n\n\n\n\nFigure 14.6 shows a more advanced modification of the chart. It adds x and y axes, next, it adds a title to the chart, flips the chart coordinates, and changes the chart background color and title size. Next, it moves the chart to the top left corner of the map and sets its width. Having such a customized chart provides all of the important map context information: variable name, unit, ranges of the values and their related colors. Thus, we can treat it as a map legend and remove the default legend using fill.legend = tm_legend(show = FALSE).\n\ntm_shape(slo_regions) +\n  tm_polygons(fill = \"pop_dens\",\n              fill.chart = tm_chart_histogram(\n                plot.axis.x = TRUE,\n                plot.axis.y = TRUE,\n                extra.ggplot2 = list(\n                  labs(title = \"Population density (people/sq. km)\"),\n                  coord_flip(),\n                  theme(plot.background = element_rect(fill = \"#FFC067\"),\n                        plot.title = ggplot2::element_text(size = 10))),\n                position = tm_pos_in(\"LEFT\", \"TOP\"),\n                width = 20,\n              ),\n              fill.legend = tm_legend(show = FALSE))\n\n\n\n\n\n\nFigure 14.6: Using chart as a map legend.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Charts</span>"
    ]
  },
  {
    "objectID": "arrangements.html",
    "href": "arrangements.html",
    "title": "15  Arranging maps",
    "section": "",
    "text": "15.1 Inset maps\nThe tmap package offers several tools for arranging multiple maps within a single layout. When we want to display one main map and one or more additional maps, we can use tm_minimap() or tm_inset(). The first function adds a small overview map to the main map using a fixed, non-customizable style (Section 10.7). More advanced arrangements can be made with the tm_inset() function, which adds a graphical object (including a tmap object) to the main map (Section 15.1).\nTo create a layout with multiple maps, we have two main options. The first one, which is the focus of this chapter, is to use the tmap_arrange() function. It takes two or more tmap objects and arranges them in a grid layout as you can learn in Section 15.2 and Section 15.3. The second option is to create facets with the tm_facet() function, which is described in Chapter 16. The main difference is that tmap_arrange() combines multiple maps, often based on different data, while tm_facet() creates a single map with numerous panels based on the same data.\nInset maps are a powerful way to add additional context or details to a main map. They are typically smaller maps that show a specific area of interest, such as a zoomed-in view of a region, or a different data layer that complements the main map. In tmap, insets may be based on a bounding box, another tmap object, ggplot2 objects, or image files. To add an inset map to a main map, we can use the tm_inset() function.\nFigure 15.1 shows how to add multiple inset maps to a main map. Each inset is defined by a bounding box using the tmaptools::bb() function, which takes a place name as input and returns a bounding box for that place.1 In such cases, inset maps are added to the main map, with the same extent as the bounding box and the same style as the main map.\nlibrary(tmap)\nlibrary(terra)\nslo_elev = rast(\"data/slovenia/slo_elev.tif\")\ntm_shape(slo_elev) +\n  tm_raster() +\n  tm_inset(tmaptools::bb(\"Maribor\")) +\n  tm_inset(tmaptools::bb(\"Ljubljana\")) +\n  tm_inset(tmaptools::bb(\"Bled\"))\n\n\n\n\n\n\nFigure 15.1: Inset maps based on bounding boxes.\nThe above map can be further customized by improving the color palette and adding titles to the inset maps. We can use the tm_title() function to add titles to the inset maps, and the tm_inset() function to specify the bounding boxes for each inset map. Then, each of these components can be grouped using the group_id argument and arranged using the tm_components() function (Section 11.2).\ntm_shape(slo_elev) +\n  tm_raster(\n    col.scale = tm_scale_continuous(values = \"geyser\", midpoint = NA)\n  ) +  \n  tm_title(\"Maribor\", group_id = 1) +\n  tm_inset(tmaptools::bb(\"Maribor\"), group_id = 1) +\n  tm_title(\"Ljubljana\", group_id = 1) +\n  tm_inset(tmaptools::bb(\"Ljubljana\"), group_id = 1) +\n  tm_title(\"Bled\", group_id = 2) +\n  tm_inset(tmaptools::bb(\"Bled\"), group_id = 2) +\n  tm_components(1, position = c(\"right\", \"bottom\")) +\n  tm_components(2, position = c(\"left\", \"top\"))\n\n\n\n\n\n\nFigure 15.2: Customized inset maps.\nThe tm_inset() function can also be used to add a tmap object as an inset map. In the following example, we create a tmap object for Slovenia’s elevation. Importantly, we set the limits of the color scale to match the limits of the elevation data of the main map and remove the legend using the tm_legend(show = FALSE) argument. We also add a scale bar to the inset map using the tm_scalebar() function to facilitate a better understanding of the area’s size shown in the inset.\ntm_slo_elev = tm_shape(slo_elev) +\n  tm_raster(\n    col.scale = tm_scale_continuous(values = \"geyser\", midpoint = NA,\n                                    limits = c(-100, 4000)),\n    col.legend = tm_legend(show = FALSE)\n  ) +\n  tm_scalebar(breaks = c(0, 10, 20),\n              position = c(\"RIGHT\", \"BOTTOM\"))\nNow, we can create our main map and add the inset map based on the tm_slo_elev object (Figure 15.3). The main map in our case would be the elevation of Europe, using the same color scale as the inset map – however, this time, we will include the legend.\nworldelevation = rast(\"data/worldelevation.tif\")\ntm_shape(worldelevation, bbox = \"Europe\") +\n  tm_raster(\n    col.scale = tm_scale_continuous(values = \"geyser\", midpoint = NA,\n                                    limits = c(-100, 4000))\n  ) +\n  tm_scalebar() +\n  tm_title(\"Slovenia\", group_id = 1) +\n  tm_inset(tm_slo_elev, group_id = 1) +\n  tm_components(1, position = c(\"LEFT\", \"TOP\")) \n\n\n\n\n\n\nFigure 15.3: Inset maps based on tmap objects.\nThe ggplot2 package can also be used to create insets. Such insets could be based on some external data or be derived from the map data itself, and then provide additional non-spatial information. In the following example, we create a bar plot illustrating the number of people living in Slovenia’s cities and towns. The default ggplot2 theme includes many elements, such as grid lines, axis ticks, and background, which are often unnecessary in inset maps and can distract from the main map. Thus, we also remove the labeling of the axes and apply the theme_minimal() function to simplify the plot.\nlibrary(ggplot2)\nlibrary(sf)\n#&gt; Linking to GEOS 3.13.0, GDAL 3.10.3, PROJ 9.6.0; sf_use_s2() is TRUE\nslo_cities = read_sf(\"data/slovenia/slo_cities.gpkg\")\ngg1 = ggplot(slo_cities, aes(place, population)) +\n  geom_col() +\n  scale_y_continuous(labels = scales::comma) +\n  labs(x = NULL, y = NULL) +\n  theme_minimal()\nWe can add the new ggplot2 object as an inset map in the same way as we did with the tmap object. Figure 15.4 displays a map of Slovenia’s regions, with points representing cities and towns, and then adds the ggplot2 object as an inset map. It allows us to see that even though there are more towns than cities in our dataset, more people live in cities than in towns.\nslo_regions = read_sf(\"data/slovenia/slo_regions.gpkg\")\ntm_shape(slo_regions) +\n  tm_polygons(\"gdppercap\") +\n  tm_shape(slo_cities) +\n  tm_symbols(shape = \"place\") +\n  tm_labels(\"name\", bgcol = \"white\") +\n  tm_inset(gg1, position = c(\"right\", \"bottom\")) \n\n\n\n\n\n\nFigure 15.4: Inset maps based on a ggplot2 object.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arranging maps</span>"
    ]
  },
  {
    "objectID": "arrangements.html#sec-inset-maps",
    "href": "arrangements.html#sec-inset-maps",
    "title": "15  Arranging maps",
    "section": "",
    "text": "Note\n\n\n\nInsets are not usually needed in the interactive mode, as we can zoom in and out of the main map. Thus, the tm_inset() function calls only work in plot mode.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arranging maps</span>"
    ]
  },
  {
    "objectID": "arrangements.html#sec-arrangements",
    "href": "arrangements.html#sec-arrangements",
    "title": "15  Arranging maps",
    "section": "\n15.2 Basic arrangements",
    "text": "15.2 Basic arrangements\nLet’s see how the tmap_arrange() function works based on two maps of Slovenia, each based on different data sources. The first map is based on the GDP per capita of Slovenia’s regions, represented as polygons.\n\nlibrary(tmap)\nlibrary(sf)\nslo_regions = read_sf(\"data/slovenia/slo_regions.gpkg\")\ntm1 = tm_shape(slo_regions) +\n  tm_polygons(\"gdppercap\") +\n  tm_title(\"GDP per capita in Slovenia\")\n\nThe second map is based on the elevation of Slovenia, represented as a raster layer.\n\nlibrary(tmap)\nlibrary(stars)\nslo_elev = read_stars(\"data/slovenia/slo_elev.tif\")\ntm2 = tm_shape(slo_elev) +\n  tm_raster() +\n  tm_title(\"Elevation in Slovenia\")\n\nIn both cases, we also added titles to the maps using the tm_title() function to clarify what each map represents, and assigned them to the objects tm1 and tm2. Now, we may arrange these two maps in a single layout using the tmap_arrange() function (Figure 15.5). The tmap_arrange() function can take any number of tmap objects as input or even a list of tmap objects.\n\ntmap_arrange(tm1, tm2, ncol = 2)\n\n\n\n\n\n\nFigure 15.5: Arranging two maps in one layout.\n\n\n\n\nIn the example above, we used our two maps and specified the number of columns in the layout using the ncol argument. We can also specify the number of rows using the nrow argument, the aspect ratio of the maps using the asp argument, and the widths and heights of the maps using the widths and heights arguments, respectively.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arranging maps</span>"
    ]
  },
  {
    "objectID": "arrangements.html#sec-customizing-arrangements",
    "href": "arrangements.html#sec-customizing-arrangements",
    "title": "15  Arranging maps",
    "section": "\n15.3 Customizing arrangements",
    "text": "15.3 Customizing arrangements\nThe tmap_arrange() does not align layouts of multiple maps – you may notice that the frames of the two maps in Figure 15.5 are not equal in height. To align the frames of the maps, we can use the meta.margins argument in the tm_layout() function for each map. This argument allows us to specify the margins around the map frame available for map elements, such as titles and legends, in the order of c(bottom, left, top, right). \nHere, we set the bottom margin to 0.3 for both maps, which will align their frames vertically. See the effect of this change in Figure 15.6.\n\ntm1a = tm1 +\n  tm_layout(meta.margins = c(0.3, 0, 0, 0))\ntm2a = tm2 +\n  tm_layout(meta.margins = c(0.3, 0, 0, 0))\ntmap_arrange(tm1a, tm2a, ncol = 2)\n\n\n\n\n\n\nFigure 15.6: Arranging two maps in one layout with aligned frames.\n\n\n\n\nYou may also notice that, as we set the top margin of the second map to 0, the titles of both maps were moved inside the map frames. If you want to keep the titles outside, you can set the top margin of the second map to a small value, such as 0.05.\n\n\n\n\n\n\nNote\n\n\n\nThe outcomes of the tmap_arrange() function also work in the tmap view mode, which allows you to explore a few maps at once interactively.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe tmap_arrange() function call can be saved to an object, which can then be used in other functions, such as tmap_save(), to save the arranged maps to a file. For more information on saving maps, see Chapter 4.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arranging maps</span>"
    ]
  },
  {
    "objectID": "arrangements.html#footnotes",
    "href": "arrangements.html#footnotes",
    "title": "15  Arranging maps",
    "section": "",
    "text": "Alternatively, you can use a bounding box defined by a vector of coordinates, such as c(xmin, ymin, xmax, ymax) or another spatial object.↩︎",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arranging maps</span>"
    ]
  },
  {
    "objectID": "facets.html",
    "href": "facets.html",
    "title": "16  Facets",
    "section": "",
    "text": "16.1 Specifying facets\nFacets, also known as small multiples, are a powerful way to visualize multiple variables or values of a single variable in a grid of panels. In other words, they open the possibility of visualizing multiple maps in a single figure. They allow for quick comparison of different variables or values across the same regions or time periods. This chapter not only shows how to define facets in tmap but also how to customize them to make them more informative and appealing.\nTo demonstrate the use of facets, we will use a few datasets from Slovenia. This includes the borders of Slovenia (slo_borders – just one polygon), the regions of Slovenia (slo_regions – multiple polygons for many variables) and the regions of Slovenia over time (slo_regions_ts – multiple polygons with a time variable representing different years). To simplify the examples, we will subset the slo_regions_ts dataset to include only five years: 2006, 2010, 2014, 2018, and 2022.\nFacet can be based on data coming from various sources: it can be a set of variables (e.g., columns in an sf object) or a single variable with multiple values.\nThe first approach is seen below, where we specify multiple variables (c(\"pop_dens\", \"gdppercap\", \"tourism\")) from the slo_regions dataset to create facets. Each variable is displayed in its own facet with a separate scale and legend (Figure 16.1). This allows for quick comparison of different variables across the same regions.\ntm_shape(slo_regions) +\n  tm_polygons(c(\"pop_dens\", \"gdppercap\", \"tourism\"))\n\n\n\n\n\n\nFigure 16.1: Facets for different variables.\nThe second approach uses a single variable to create facets, where each facet represents a unique value of that variable. Here, we need to use tm_facets() to specify the faceting variable. This function creates a grid of panels, each showing the data for a specific value of the variable (here \"time\"), and also allows to specify the layout of the facets (e.g., number of columns) (Figure 16.2). In such cases, all of the facets share the same scale and legend, which is useful, for example, for comparing the same variable across different times.\ntm_shape(slo_regions_ts) +\n  tm_polygons(\"gdppercap\") +\n  tm_facets(by = \"time\", ncol = 5)\n\n\n\n\n\n\nFigure 16.2: Facets for one variable over time.\nBoth approaches can be combined, allowing to create facets for multiple variables over time (Figure 16.3). Here, variables specified as a visual variable (c(\"pop_dens\", \"gdppercap\", \"tourism\")) and show in columns, while the faceting variable is set with tm_facets(by = \"time\") and presents the data for each year in a separate row.\ntm_shape(slo_regions_ts) +\n  tm_polygons(c(\"pop_dens\", \"gdppercap\", \"tourism\")) +\n  tm_facets(by = \"time\")\n\n\n\n\n\n\nFigure 16.3: Facets for multiple variables over time.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "facets.html#imporance-of-layers-order-for-faceting",
    "href": "facets.html#imporance-of-layers-order-for-faceting",
    "title": "16  Facets",
    "section": "\n16.2 Imporance of layers order for faceting",
    "text": "16.2 Imporance of layers order for faceting\nThe placement of the tm_facets() function in the code is crucial for how facets are applied to the map. When presenting multiple layers in a map, the tm_facets() function must be defined after the layer to be faceted.\nMoreover, the order of layers is essential when using facets for two reasons:\n\nThe first layer in the map is used to determine the extent of the map.\nEach layer lies on top of the previous one, so the last layer is the one that is in the foreground.\n\nFigure 16.4 has the slo_borders layer first, which means that the borders of Slovenia are drawn first – each facet will have the same extent and the borders will be visible in each facet. Next, the slo_regions_ts layer is added and faceted by the region_group variable. This results in a map where each facet shows the GDP per capita for different region groups with the borders of Slovenia in the background.\n\ntm_shape(slo_borders) +\n  tm_borders(lwd = 4) +\n  tm_shape(slo_regions) +\n  tm_polygons(\"gdppercap\") +\n  tm_facets(by = \"region_group\", nrow = 2)\n\n\n\n\n\n\nFigure 16.4: Facets for one variable for different region groups.\n\n\n\n\nOn the other hand, Figure 16.5 has the slo_regions_ts layer first, which means that the GDP per capita is drawn first and then the borders of Slovenia are added. This results in a map where each facet zooms into a specific region group, showing the GDP per capita for that group.\n\ntm_shape(slo_regions) +\n  tm_polygons(\"gdppercap\") +\n  tm_facets(by = \"region_group\", nrow = 2) +\n  tm_shape(slo_borders) +\n  tm_borders(lwd = 4)\n\n\n\n\n\n\nFigure 16.5: Facets for one variable limiting the view to a specific region group.\n\n\n\n\nWhat to do in case we want to keep the borders layer on the top, but also have its extent in every panel? In this case, we may either set the slo_borders layer as a main one (tm_shape(slo_borders, is.main = TRUE); Section 5.2) or set the free.coords argument of tm_facets() to FALSE – then each facet will use the complete extent of the provided slo_regions_ts data.\n\ntm_shape(slo_regions) +\n  tm_polygons(\"gdppercap\") +\n  tm_facets(by = \"region_group\", nrow = 2, free.coords = FALSE) +\n  tm_shape(slo_borders) +\n  tm_borders(lwd = 4)",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "facets.html#facets-types",
    "href": "facets.html#facets-types",
    "title": "16  Facets",
    "section": "\n16.3 Facets types",
    "text": "16.3 Facets types\nAll of the above examples use the tm_facets() function. This is a general function that can be used to create facets for various types of data. At the same time, tmap provides several specialized functions for creating facets that can be used to create more complex faceting layouts.\nThe most common ones are:\n\n\ntm_facets_wrap() – creates facets that wrap around the specified variable – it can be thought as a one-dimensional grid of panels\n\ntm_facets_grid() – creates facets in a two-dimensional grid, where the specified variables define the rows and columns\n\nFigure 16.6 shows how to use tm_facets_wrap() to create facets for the region_group variable, wrapping the panels into two rows. By default, the panels are filled from left to right, and then from top to bottom, but we can change this behavior by setting the byrow argument to FALSE.\n\ntm_shape(slo_borders) +\n  tm_borders(lwd = 4) +\n  tm_shape(slo_regions) +\n  tm_polygons(\"gdppercap\") +\n  tm_facets_wrap(by = \"region_group\", nrow = 2, byrow = FALSE)\n\n\n\n\n\n\nFigure 16.6: Facets for one variable with wrapping.\n\n\n\n\nTwo-dimensional facets are shown in Figure 16.7, where the region_group variable is used for the rows and the time variable for the columns.\n\ntm_shape(slo_borders) +\n  tm_borders(lwd = 4) +\n  tm_shape(slo_regions_ts) +\n  tm_polygons(\"gdppercap\") +\n  tm_facets_grid(rows = \"region_group\", columns = \"time\")\n\n\n\n\n\n\nFigure 16.7: Two-dimensional facets for one variable in various region groups over time.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "facets.html#sec-customizing-facets",
    "href": "facets.html#sec-customizing-facets",
    "title": "16  Facets",
    "section": "\n16.4 Customizing facets",
    "text": "16.4 Customizing facets\nNow that we know how to create facets, we can customize them to make them more informative and to focus on the message we want to convey. Often, faceting variables are self-explanatory – we can easily understand what their values mean. However, sometimes, we want to add more information to the facets, such as labels for the axes or titles for the panels.\nThe labels can be added using the tm_xlab() and tm_ylab() functions (Figure 16.8). By default, they are located on the bottom and left side of the map, but we can change their position using the side argument. Moreover, they maintain a horizontal orientation. This is fine for the x-axis, but not for the y-axis, where we may want to rotate the label to be vertical with the rotation argument. Finally, we could customize their size and distance from the map border to make them more readable using the size and space arguments, respectively.\n\ntm_shape(slo_borders) +\n  tm_borders(lwd = 4) +\n  tm_shape(slo_regions_ts) +\n  tm_polygons(\"gdppercap\") +\n  tm_facets_grid(rows = \"region_group\", columns = \"time\") +\n  tm_xlab(\"Year\", side = \"top\", size = 2, space = 1) +\n  tm_ylab(\"Region\", rotation = 90, size = 2, space = 1)\n\n\n\n\n\n\nFigure 16.8: Two-dimensional facets with labeled axes.\n\n\n\n\n\nPanel labels can be adjusted using the tm_layout(panel.labels = c(...)) function. To see it in action, we read the slo_tavg raster data, which contains average monthly temperatures in Slovenia.  \n\nlibrary(stars)\nslo_tavg = read_stars(\"data/slovenia/slo_tavg.tif\")\n\nNext, we create facets for the raster data using tm_facets(), specify the band variable that stores the month information and set the number of columns to three. This results in a grid of panels, each showing the average temperature for a specific month, with the panel labels based on the band variable name. Such a name is usually not very informative, so we can replace it with more descriptive labels with a vector of labels provided to the panel.labels argument of the tm_layout() function, e.g., panel.labels = c(1:12) (Figure 16.9).\n\ntm_shape(slo_tavg) +\n  tm_raster(col.scale = tm_scale_continuous()) +\n  tm_facets(by = \"band\", ncol = 3) +\n  tm_layout(panel.labels = c(1:12))\n\n\n\n\n\n\nFigure 16.9: Facets for raster data.\n\n\n\n\nNote that in the above example only one legend is shown and it is shared across all panels. This allows for easy comparison of the values across different months, e.g., we can see that the average temperature in January is much lower than in July.\n\nOn the other hand, we may be interested in comparing the spatial patterns of average temperatures across different months rather than their values. To do that, we need to create independent legends for each panel – we should set the col.free argument of tm_raster() to TRUE (Figure 16.10). In the example below, we also customize the map further by updating the color scale to use the “viridis” palette, removing the title from the legend and adding a title to the map, improving the panel labels, adjusting the inner margins of the facets to make them more readable.\n\ntm_shape(slo_tavg) +\n  tm_raster(\n    col.scale = tm_scale_continuous(values = \"viridis\"),\n    col.legend = tm_legend(title = \"\", position = c(\"LEFT\", \"BOTTOM\")),\n    col.free = TRUE) +\n  tm_facets(by = \"band\", ncol = 3) +\n  tm_layout(panel.labels = c(1:12),\n            inner.margins = c(0.02, 0.2, 0.02, 0.02)) +\n  tm_title(\"Average monthly temperature in Slovenia\") \n\n\n\n\n\n\nFigure 16.10: Facets for raster data independent legends.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "facets.html#facets-with-raster-and-vector-data",
    "href": "facets.html#facets-with-raster-and-vector-data",
    "title": "16  Facets",
    "section": "\n16.5 Facets with raster and vector data",
    "text": "16.5 Facets with raster and vector data\nFigure 16.11 shows how to combine raster and vector data in facets. In this example, we use the slo_elev raster data, which contains elevation data for Slovenia, and the slo_regions vector data, which includes the borders of the regions in Slovenia. To display the elevation data for each region group, we must first specify the raster data and then use the vector data as the main layer (is.main = TRUE in tm_shape()). Next, we can use tm_facets() to create facets for the region_group variable.\n\nslo_elev = read_stars(\"data/slovenia/slo_elev.tif\")\ntm_shape(slo_elev) +\n  tm_raster(col.scale = tm_scale_continuous()) +\n  tm_shape(slo_regions, is.main = TRUE) + \n  tm_borders(lwd = 4) +\n  tm_facets(by = \"region_group\", free.coords = TRUE)\n\n\n\n\n\n\nFigure 16.11: Facets with raster data and vector data.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "animations.html",
    "href": "animations.html",
    "title": "17  Animations",
    "section": "",
    "text": "17.1 Creating animations\nAnimations are a powerful way to visualize changes in data over time – to illustrate trends, patterns, and dynamics that might not be immediately apparent in static maps. They can also be used to create engaging visualizations that capture the viewer’s attention or just to break the monotony of static maps, for example, by comparing different locations.\nIn tmap, animations are created by stitching together a series of static maps into a single animated image. This is done with two types of functions:\nLet’s create some animations using the slo_regions_ts dataset, which contains various measures of Slovenian regions over time.\nlibrary(sf)\nlibrary(tmap)\nslo_regions_ts = read_sf(\"data/slovenia/slo_regions_ts.gpkg\")\nThe basis for our animations is a tmap object that contains the data and the way we want to visualize it.\ntm = tm_shape(slo_regions_ts) +\n  tm_polygons(\"gdppercap\")\nTo make it animated, we can use the tm_animate() or tm_animate_fast() functions and specify the variable that we want to animate by, in this case, time (Figure 17.1). The difference between the two functions is that tm_animate() renders the animation at 2 frames per second (specified by the fps argument), while tm_animate_fast() renders it at 24 frames per second. The former is more suitable for smaller datasets and cases where we want to allow the viewer to read the values on the map, while the latter is more suitable for larger datasets and cases where we want to create a smooth, cinematic animation.\ntm +\n  tm_animate(by = \"time\")\n\n\n\n\n\n\nFigure 17.1: Animations of GDP per capita in Slovenian regions over time using tm_animate()\nTwo main additional arguments for the animate functions are fps (frames per second) and play (playback mode). The first one controls the speed of the animation, while the second one controls how the animation is played back: either \"loop\" (default), which plays the animation in a loop, \"once\", which plays the animation only once and then stops, or \"pingpong\" which plays the animation back and forth (Figure 17.2).\ntm +\n  tm_animate(by = \"time\", fps = 5, play = \"pingpong\")\n\n\n\n\n\n\nFigure 17.2: Animations of GDP per capita in Slovenian regions over time with a pingpong playback mode\nAnimations can also be created from raster data, such as satellite imagery or climate data. Figure 17.3 shows an example of an animation of the average temperature in Slovenia over monthly time steps. First, the raster data is defined, and its scale is set to the continuous one. Next, we define the animation using tm_animate() and specify the by argument to animate by the band variable, which represents the time steps in the raster data. Finally, we add the borders of Slovenian regions to the map to provide context for the animation.\nlibrary(stars)\nslo_tavg = read_stars(\"data/slovenia/slo_tavg.tif\")\nslo_regions = read_sf(\"data/slovenia/slo_regions.gpkg\")\ntm_shape(slo_tavg) +\n  tm_raster(col.scale = tm_scale_continuous()) +\n  tm_animate(by = \"band\", fps = 6) +\n  tm_shape(slo_regions) +\n  tm_borders()\n\n\n\n\n\n\nFigure 17.3: Animation of average temperature in Slovenia over time",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Animations</span>"
    ]
  },
  {
    "objectID": "animations.html#saving-animations",
    "href": "animations.html#saving-animations",
    "title": "17  Animations",
    "section": "\n17.2 Saving animations",
    "text": "17.2 Saving animations\nThe tm_animate() and tm_animate_fast() functions create a tmap object that contains the animation and shows it. Now, to save the animation, we can use the tmap_animation() function. It takes the animation object as the first argument and the file name as the second argument – the extension of the file name determines the format of the saved animation. We may save the animation in either graphical format (GIF) or video format (including MP4).\n\ntma1 = tm +\n  tm_animate_fast(by = \"time\")\ntmap_animation(tma1, \"tma1.gif\")\n# or\n# tmap_animation(tma1, \"tma1.mp4\")\n\nAdditionally, we can customize the output of the animation with various arguments, such as width, height, dpi, asp, and scale (similarly to tmap_save() as shown in Chapter 4). Moreover, if the animation is saved in a video format, we can also specify various additional arguments, such as codec from the av package1.",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Animations</span>"
    ]
  },
  {
    "objectID": "animations.html#footnotes",
    "href": "animations.html#footnotes",
    "title": "17  Animations",
    "section": "",
    "text": "Check the documentation of the av::av_encode_video() function for more details.↩︎",
    "crumbs": [
      "Expanding the toolbox",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Animations</span>"
    ]
  },
  {
    "objectID": "options.html",
    "href": "options.html",
    "title": "19  tmap options",
    "section": "",
    "text": "19.1 Raster resolution\nRaster data is represented by a grid of cells (Section 2.2.2), and the number of cells impacts the time to render a map. Rasters with hundreds of cells will be plotted quickly, while rasters with hundreds of millions or billions of cells will take a lot of time (and RAM) to be shown.  Therefore, the tmap package downsamples large rasters by default to be below 10,000,000 cells in the plot mode and 1,000,000 cells in the view mode.  This values can be adjusted with the raster.max_cells argument of tmap_options(), which expects a named vector with two elements - plot and view (Figure 19.1).\ntmap_options(raster.max_cells = c(plot = 5000, view = 2000))\ntm_shape(worldelevation) +\n  tm_raster(\"worldelevation.tif\")\n\n\n\n\n\n\nFigure 19.1: A raster map with the decreased resolution",
    "crumbs": [
      "Advanced topics",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>tmap options</span>"
    ]
  },
  {
    "objectID": "options.html#resetting-the-options",
    "href": "options.html#resetting-the-options",
    "title": "19  tmap options",
    "section": "\n19.2 Resetting the options",
    "text": "19.2 Resetting the options\nAny tmap options can be reset (set to default) with tmap_options_reset().\n\ntmap_options_reset()",
    "crumbs": [
      "Advanced topics",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>tmap options</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Birch, Jennifer. 2012. “Worldwide Prevalence of Red-Green Color\nDeficiency.” Journal of the Optical Society of America A\n29 (3): 313. https://doi.org/10/ggkw82.\n\n\nBivand, Roger. 2020. classInt: Choose Univariate Class\nIntervals. https://CRAN.R-project.org/package=classInt.\n\n\nBorland, David, and Russell Taylor Ii. 2007. “Rainbow Color\nMap (Still) Considered Harmful.”\nIEEE Computer Graphics and Applications 27 (2): 14–17. https://doi.org/10/cf7nms.\n\n\nCARTO. 2019. “CARTOColors\nData-Driven Color Schemes.”\nhttps://carto.com/carto-colors/.\n\n\nChang, Winston. 2014. Extrafont: Tools for Using Fonts. https://CRAN.R-project.org/package=extrafont.\n\n\nCoombes, Kevin R., Guy Brock, Zachary B. Abrams, and Lynne V. Abruzzo.\n2019. “Polychrome :\nCreating and Assessing Qualitative Palettes\nwith Many Colors.” Journal of Statistical\nSoftware 90 (Code Snippet 1). https://doi.org/10/ggkqvs.\n\n\nCrameri, Fabio. 2018. “Geodynamic Diagnostics, Scientific\nVisualisation and StagLab 3.0.” Geoscientific\nModel Development 11 (6): 2541–62. https://doi.org/10/gdt4tg.\n\n\nFisher, Walter D. 1958. “On Grouping for\nMaximum Homogeneity.” Journal of the American\nStatistical Association, 10. https://doi.org/10/gkb5sf.\n\n\nGarnier, Simon. 2018. Viridis: Default Color Maps from\n’Matplotlib’. https://CRAN.R-project.org/package=viridis.\n\n\nGuidero, Elaine. 2017. “Typography.” In Geographic\nInformation Science & Technology Body of\nKnowledge, edited by John P. Wilson. Vol. 2017.\nUniversity Consortium for Geographic Information Science\n(UCGIS).\n\n\nHarrower, Mark, and Cynthia A. Brewer. 2003.\n“ColorBrewer.org: An Online Tool for\nSelecting Colour Schemes for Maps.”\nThe Cartographic Journal 40 (1): 27–37. https://doi.org/10/ch4c57.\n\n\nJiang, Bin. 2013. “Head/Tail Breaks: A New\nClassification Scheme for Data with a\nHeavy-Tailed Distribution.” The\nProfessional Geographer 65 (3): 482–94. https://doi.org/10/f24r6j.\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2025.\nGeocomputation with R. Second. CRC\nPress.\n\n\nNeuwirth, Erich. 2014. RColorBrewer: ColorBrewer Palettes. https://CRAN.R-project.org/package=RColorBrewer.\n\n\nNowosad, Jakub. 2018. ’CARTOColors’ Palettes. https://nowosad.github.io/rcartocolor.\n\n\nNuñez, Jamie R., Christopher R. Anderton, and Ryan S. Renslow. 2018.\n“Optimizing Colormaps with Consideration for Color Vision\nDeficiency to Enable Accurate Interpretation of Scientific Data.”\nEdited by Jesús Malo. PLOS ONE 13 (7): e0199239. https://doi.org/10/gdzkg4.\n\n\nPedersen, Thomas Lin, and Fabio Crameri. 2020. Scico: Colour\nPalettes Based on the Scientific Colour-Maps. https://CRAN.R-project.org/package=scico.\n\n\nPedersen, Thomas Lin, Jeroen Ooms, and Devon Govett. 2021.\nSystemfonts: System Native Font Finding. https://CRAN.R-project.org/package=systemfonts.\n\n\nPedersen, Thomas Lin, and Maxim Shemanarev. 2021. Ragg: Graphic\nDevices Based on AGG. https://CRAN.R-project.org/package=ragg.\n\n\nPeng, Roger. 2016. Exploratory Data Analysis with\nR. United States: LeanPub.\n\n\nQiu, Yixuan, and authors/contributors of the included software. See file\nAUTHORS for details. 2021. Showtext: Using Fonts More Easily in r\nGraphs. https://CRAN.R-project.org/package=showtext.\n\n\nQuinan, P. S., L. M. Padilla, S. H. Creem-Regehr, and M. Meyer. 2019.\n“Examining Implicit Discretization in Spectral\nSchemes.” Computer Graphics Forum 38 (3): 363–74.\nhttps://doi.org/10/ggb9nd.\n\n\nŠavrič, Bojan, Tom Patterson, and Bernhard Jenny. 2019. “The\nEqual Earth Map Projection.” International\nJournal of Geographical Information Science 33 (3): 454–65. https://doi.org/10/cs8v.\n\n\nSharpe, Lindsay T, Andrew Stockman, Herbert Jägle, and Jeremy Nathans.\n1999. “Opsin Genes, Cone Photopigments, Color Vision, and Color\nBlindness.” In Color Vision: From Genes to\nPerception, edited by T Gegenfurtner and Lindsay T\nSharpe, 50. Cambridge: Cambridge University\nPress.\n\n\nStauffer, Reto, Georg J. Mayr, Markus Dabernig, and Achim Zeileis. 2015.\n“Somewhere Over the Rainbow:\nHow to Make Effective Use of\nColors in Meteorological\nVisualizations.” Bulletin of the American\nMeteorological Society 96 (2): 203–16. https://doi.org/10/f3sttk.\n\n\nWand, M. P. 1997. “Data-Based Choice of\nHistogram Bin Width.” The American\nStatistician 51 (1): 59. https://doi.org/10/fvsfdb.\n\n\nZeileis, Achim, Jason C. Fisher, Kurt Hornik, Ross Ihaka, Claire D.\nMcWhite, Paul Murrell, Reto Stauffer, and Claus O. Wilke. 2019.\n“colorspace: A Toolbox for\nManipulating and Assessing Colors and Palettes.” arXiv\n1903.06490. arXiv.org E-Print Archive. http://arxiv.org/abs/1903.06490.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "data_processing.html",
    "href": "data_processing.html",
    "title": "Appendix A — Data preparation",
    "section": "",
    "text": "A.1 Data simplification\nGeometries in spatial vector data consists of sets of coordinates (Section 2.2.1). Spatial vector objects grow larger with more features to present and more details to show, and this also has an impact on time to render a map.  Figure A.1 (a) shows a map of countries from the worldvector object.\ntm_shape(worldvector) +\n  tm_polygons()\nThis level of detail can be good for some maps, but sometimes the number of details can make reading the map harder. To create a simplified (smoother) version of vector data, we can use the ms_simplify function of the rmapshaper package. . It expects a numeric value from 0 to 1 – a proportion of vertices in the data to retain. In the example below, we set keep to 0.05, which keeps 5% of vertices (Figure A.1 (b)).\nlibrary(rmapshaper)\nworldvector_s1 = ms_simplify(worldvector, keep = 0.05)\ntm_shape(worldvector_s1) +\n  tm_polygons()\nThe process of simplification can also be more controlled. By default, the underlining algorithm (called the Visvalingam method, learn more at https://bost.ocks.org/mike/simplify/), removes small features, such as islands in our case. This could have far-reaching consequences - in the process of simplification, we could remove some countries! To prevent the deletion of small features, we also need to set keep_shapes to TRUE. In the case of one country consisting of many small polygons, only one is sure to be retained. For example, look at New Zealand, which is now only represented by Te Waipounamu (the South Island). To keep all of the spatial geometries (even the smallest of islands), we should also specify explode to TRUE.\nworldvector_s2 = ms_simplify(worldvector, keep = 0.05,\n                             keep_shapes = TRUE, explode = TRUE)\ntm_shape(worldvector_s2) +\n  tm_polygons()\nFigure A.1 (c) contains a simplified map, where each spatial geometry of the original map still exists, but in a less detailed form.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Data preparation</span>"
    ]
  },
  {
    "objectID": "data_processing.html#sec-data-simplification",
    "href": "data_processing.html#sec-data-simplification",
    "title": "Appendix A — Data preparation",
    "section": "",
    "text": "(a) original data\n\n\n\n\n\n\n\n\n\n(b) simplified data with 5% of vertices kept\n\n\n\n\n\n\n\n\n\n(c) simplified data with 5% of vertices, all features, and all polygons kept\n\n\n\n\n\n\nFigure A.1: A map of world’s countries based on:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Data preparation</span>"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Appendix B — Glossary",
    "section": "",
    "text": "Table B.1\n\n\n\n\n    \n\n      \n\n..\n              \nTerm\n                Explanation\n              \n\n\n\nAuxiliary map layer\n                  An auxiliary (or non-data-driven) map layer is a visual representation of geographic information that does not come from a spatial object, but uses the map's coordinates. Examples: `tm_grid()`/`tm_graticules()` and `tm_basemap()`.\n                \n\nData-driven map layer\n                  A data-driven map layer is a visual representation of a spatial object. E.g., `tm_polygons()` or `tm_raster()`.\n                \n\nFacets\n                  Multiple maps in one plot. Also called 'small multiples'.\n                \n\nFeatures\n                  Elementary spatial data objects. For instance, a row in an `sf` data.frame or a single raster cell.\n                \n\nGlyph\n                  Mini charts that are used as proportional symbols. See the extension package `tmap.glyphs`.\n                \n\nLayout\n                  All aspects that specify the plot apart from the map layers and map components. Examples: margins, background color, aspect ratio, font sizes, etc. These can be set via `tm_layout`. These layout options form a subset of all tmap options (see **options**).\n                \n\nMap component\n                  A visual plot object with a position independent of map coordinates. Examples: a legend, a compass, a title.\n                \n\nMap layer\n                  A map layer is a visual representation of geographical information. We distinguish two types: *data-driven* and *auxiliary* map layers. The former requires spatial objects whereas the latter only the geographic information (bounding box and coordinate reference system).\n                \n\nOptions\n                  In the context of tmap, we refer to the options as settings, which can be configured using `tm_options`. These can be *layout* options (see **layout**) or otherwise (e.g., `'show.messages'`).\n                \n\nProportional symbols\n                  Proportional symbols are symbols that are drawn at geographic locations and that are sized proportionally with a data variable. The result is known as a 'proportional symbol map'. These symbols are usually bubbles (filled circles), but can also be small charts, called **glyphs**.\n                \n\nScale function\n                  A scale function determines how to scale a data variable to either a visual variable or a transformation variable. Examples: `tm_scale_continuous`, `tm_scale_categorical`.\n                \n\ntmap element\n                  A `tm_` object that can be stacked with the `+` operator. These are: `tm_shape()`, map layer functions (such as `tm_polygons()`), facet specification function `tm_facets()`, map components (such as `tm_compass()`), and layout/option specification functions, such as `tm_layout()`.\n                \n\nShape (object)\n                  'Shape' is a nickname for a spatial data object. It is used in `tm_shape()`.\n                \n\nShape (visual variable)\n                  The shape is a visual variable for some map layer functions, most prominently `tm_symbols()`. It determines the shape/design of the symbols.\n                \n\nStyle\n                  The overall layout of the map. Similar to ggplot2's 'theme' (see **theme**).\n                \n\nTheme\n                  tmap stands for 'thematic maps', where *theme* refers to the topic of the data plotted on a map. Note that in ggplot2, a 'theme' refers to the overall layout, e.g. `ggplot2::theme_minimal()`. In tmap, we use **style** for this.\n                \n\nTransformation variable\n                  A variable of a data-driven map layer that determines a *transformation* of the spatial object. (TO DO: exact definition). For instance, `tm_cartogram(size = \"var\")`.\n                \n\nVisual variable\n                  A variable of a data-driven map layer that determines a *visual* aspect. This can be data-driven, e.g. `tm_polygons(fill = \"var\")`, where `var` is the name of an `sf` column, or a constant value, such as `tm_polygons(fill = \"blue\")`.\n                \n\nChart\n                  A small non-spatial data visualization. In tmap for several purposes: 1) an addition to a legend `tm_polygons(fill = \"var\", fill.chart = tm_chart_histogram())`, 2) a glyph (see **glyphs**), 3) a custom chart plotted as an inset.\n                \n\nInset\n                  A visual object that is plotted on a specific (pre-defined) location. It can be a small map (**minimap**) or a **chart**.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Glossary</span>"
    ]
  }
]